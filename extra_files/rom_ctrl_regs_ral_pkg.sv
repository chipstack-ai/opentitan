// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package rom_ctrl_regs_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class rom_ctrl_regs_reg_alert_test;
  typedef class rom_ctrl_regs_reg_fatal_alert_cause;
  typedef class rom_ctrl_regs_reg_digest;
  typedef class rom_ctrl_regs_reg_exp_digest;
  typedef class rom_ctrl_regs_reg_block;

  class rom_ctrl_regs_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal;

    `uvm_object_utils(rom_ctrl_regs_reg_alert_test)

    function new(string       name = "rom_ctrl_regs_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal =
          (dv_base_reg_field::
           type_id::create("fatal"));
      fatal.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : rom_ctrl_regs_reg_alert_test

  class rom_ctrl_regs_reg_fatal_alert_cause extends dv_base_reg;
    // fields
    rand dv_base_reg_field checker_error;
    rand dv_base_reg_field integrity_error;

    `uvm_object_utils(rom_ctrl_regs_reg_fatal_alert_cause)

    function new(string       name = "rom_ctrl_regs_reg_fatal_alert_cause",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      checker_error =
          (dv_base_reg_field::
           type_id::create("checker_error"));
      checker_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      checker_error.set_original_access("RO");
      integrity_error =
          (dv_base_reg_field::
           type_id::create("integrity_error"));
      integrity_error.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      integrity_error.set_original_access("RO");
    endfunction : build
  endclass : rom_ctrl_regs_reg_fatal_alert_cause

  class rom_ctrl_regs_reg_digest extends dv_base_reg;
    // fields
    rand dv_base_reg_field digest;

    `uvm_object_utils(rom_ctrl_regs_reg_digest)

    function new(string       name = "rom_ctrl_regs_reg_digest",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      digest =
          (dv_base_reg_field::
           type_id::create("digest_0"));
      digest.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest.set_original_access("RO");
    endfunction : build
  endclass : rom_ctrl_regs_reg_digest

  class rom_ctrl_regs_reg_exp_digest extends dv_base_reg;
    // fields
    rand dv_base_reg_field digest;

    `uvm_object_utils(rom_ctrl_regs_reg_exp_digest)

    function new(string       name = "rom_ctrl_regs_reg_exp_digest",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      digest =
          (dv_base_reg_field::
           type_id::create("digest_0"));
      digest.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest.set_original_access("RO");
    endfunction : build
  endclass : rom_ctrl_regs_reg_exp_digest

  class rom_ctrl_regs_reg_block extends dv_base_reg_block;
    // registers
    rand rom_ctrl_regs_reg_alert_test alert_test;
    rand rom_ctrl_regs_reg_fatal_alert_cause fatal_alert_cause;
    rand rom_ctrl_regs_reg_digest digest[8];
    rand rom_ctrl_regs_reg_exp_digest exp_digest[8];

    `uvm_object_utils(rom_ctrl_regs_reg_block)

    function new(string name = "rom_ctrl_regs_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (rom_ctrl_regs_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg_regs.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      fatal_alert_cause =
          (rom_ctrl_regs_reg_fatal_alert_cause::
           type_id::create("fatal_alert_cause"));
      fatal_alert_cause.configure(.blk_parent(this));
      fatal_alert_cause.build(csr_excl);
      default_map.add_reg(.rg(fatal_alert_cause),
                          .offset(32'h4));
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg_regs.u_fatal_alert_cause_checker_error.q",
          0, 1, 0, "BkdrRegPathRtl");
      fatal_alert_cause.add_hdl_path_slice(
          "u_reg_regs.u_fatal_alert_cause_integrity_error.q",
          1, 1, 0, "BkdrRegPathRtl");

      digest[0] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_0"));
      digest[0].configure(.blk_parent(this));
      digest[0].build(csr_excl);
      default_map.add_reg(.rg(digest[0]),
                          .offset(32'h8));
      digest[0].add_hdl_path_slice(
          "u_reg_regs.u_digest_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[1] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_1"));
      digest[1].configure(.blk_parent(this));
      digest[1].build(csr_excl);
      default_map.add_reg(.rg(digest[1]),
                          .offset(32'hc));
      digest[1].add_hdl_path_slice(
          "u_reg_regs.u_digest_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[2] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_2"));
      digest[2].configure(.blk_parent(this));
      digest[2].build(csr_excl);
      default_map.add_reg(.rg(digest[2]),
                          .offset(32'h10));
      digest[2].add_hdl_path_slice(
          "u_reg_regs.u_digest_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[3] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_3"));
      digest[3].configure(.blk_parent(this));
      digest[3].build(csr_excl);
      default_map.add_reg(.rg(digest[3]),
                          .offset(32'h14));
      digest[3].add_hdl_path_slice(
          "u_reg_regs.u_digest_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[4] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_4"));
      digest[4].configure(.blk_parent(this));
      digest[4].build(csr_excl);
      default_map.add_reg(.rg(digest[4]),
                          .offset(32'h18));
      digest[4].add_hdl_path_slice(
          "u_reg_regs.u_digest_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[4].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[5] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_5"));
      digest[5].configure(.blk_parent(this));
      digest[5].build(csr_excl);
      default_map.add_reg(.rg(digest[5]),
                          .offset(32'h1c));
      digest[5].add_hdl_path_slice(
          "u_reg_regs.u_digest_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[5].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[6] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_6"));
      digest[6].configure(.blk_parent(this));
      digest[6].build(csr_excl);
      default_map.add_reg(.rg(digest[6]),
                          .offset(32'h20));
      digest[6].add_hdl_path_slice(
          "u_reg_regs.u_digest_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[6].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      digest[7] =
          (rom_ctrl_regs_reg_digest::
           type_id::create("digest_7"));
      digest[7].configure(.blk_parent(this));
      digest[7].build(csr_excl);
      default_map.add_reg(.rg(digest[7]),
                          .offset(32'h24));
      digest[7].add_hdl_path_slice(
          "u_reg_regs.u_digest_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[7].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[0] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_0"));
      exp_digest[0].configure(.blk_parent(this));
      exp_digest[0].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[0]),
                          .offset(32'h28));
      exp_digest[0].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[1] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_1"));
      exp_digest[1].configure(.blk_parent(this));
      exp_digest[1].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[1]),
                          .offset(32'h2c));
      exp_digest[1].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[2] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_2"));
      exp_digest[2].configure(.blk_parent(this));
      exp_digest[2].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[2]),
                          .offset(32'h30));
      exp_digest[2].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[3] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_3"));
      exp_digest[3].configure(.blk_parent(this));
      exp_digest[3].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[3]),
                          .offset(32'h34));
      exp_digest[3].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[4] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_4"));
      exp_digest[4].configure(.blk_parent(this));
      exp_digest[4].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[4]),
                          .offset(32'h38));
      exp_digest[4].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_4.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[4].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[5] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_5"));
      exp_digest[5].configure(.blk_parent(this));
      exp_digest[5].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[5]),
                          .offset(32'h3c));
      exp_digest[5].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_5.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[5].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[6] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_6"));
      exp_digest[6].configure(.blk_parent(this));
      exp_digest[6].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[6]),
                          .offset(32'h40));
      exp_digest[6].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_6.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[6].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      exp_digest[7] =
          (rom_ctrl_regs_reg_exp_digest::
           type_id::create("exp_digest_7"));
      exp_digest[7].configure(.blk_parent(this));
      exp_digest[7].build(csr_excl);
      default_map.add_reg(.rg(exp_digest[7]),
                          .offset(32'h44));
      exp_digest[7].add_hdl_path_slice(
          "u_reg_regs.u_exp_digest_7.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(exp_digest[7].get_full_name(),
                        CsrExclCheck, CsrAllTests);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : rom_ctrl_regs_reg_block

endpackage

