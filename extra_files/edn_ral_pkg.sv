// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package edn_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class edn_reg_intr_state;
  typedef class edn_reg_intr_enable;
  typedef class edn_reg_intr_test;
  typedef class edn_reg_alert_test;
  typedef class edn_reg_regwen;
  typedef class edn_reg_ctrl;
  typedef class edn_reg_boot_ins_cmd;
  typedef class edn_reg_boot_gen_cmd;
  typedef class edn_reg_sw_cmd_req;
  typedef class edn_reg_sw_cmd_sts;
  typedef class edn_reg_hw_cmd_sts;
  typedef class edn_reg_reseed_cmd;
  typedef class edn_reg_generate_cmd;
  typedef class edn_reg_max_num_reqs_between_reseeds;
  typedef class edn_reg_recov_alert_sts;
  typedef class edn_reg_err_code;
  typedef class edn_reg_err_code_test;
  typedef class edn_reg_main_sm_state;
  typedef class edn_reg_block;

  class edn_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field edn_cmd_req_done;
    rand dv_base_reg_field edn_fatal_err;

    `uvm_object_utils(edn_reg_intr_state)

    function new(string       name = "edn_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      edn_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("edn_cmd_req_done"));
      edn_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_cmd_req_done.set_original_access("W1C");
      edn_fatal_err =
          (dv_base_reg_field::
           type_id::create("edn_fatal_err"));
      edn_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_fatal_err.set_original_access("W1C");
    endfunction : build
  endclass : edn_reg_intr_state

  class edn_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field edn_cmd_req_done;
    rand dv_base_reg_field edn_fatal_err;

    `uvm_object_utils(edn_reg_intr_enable)

    function new(string       name = "edn_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      edn_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("edn_cmd_req_done"));
      edn_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_cmd_req_done.set_original_access("RW");
      edn_fatal_err =
          (dv_base_reg_field::
           type_id::create("edn_fatal_err"));
      edn_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_fatal_err.set_original_access("RW");
    endfunction : build
  endclass : edn_reg_intr_enable

  class edn_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field edn_cmd_req_done;
    rand dv_base_reg_field edn_fatal_err;

    `uvm_object_utils(edn_reg_intr_test)

    function new(string       name = "edn_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      edn_cmd_req_done =
          (dv_base_reg_field::
           type_id::create("edn_cmd_req_done"));
      edn_cmd_req_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_cmd_req_done.set_original_access("WO");
      edn_fatal_err =
          (dv_base_reg_field::
           type_id::create("edn_fatal_err"));
      edn_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_fatal_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : edn_reg_intr_test

  class edn_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_alert;
    rand dv_base_reg_field fatal_alert;

    `uvm_object_utils(edn_reg_alert_test)

    function new(string       name = "edn_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_alert =
          (dv_base_reg_field::
           type_id::create("recov_alert"));
      recov_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_alert.set_original_access("WO");
      fatal_alert =
          (dv_base_reg_field::
           type_id::create("fatal_alert"));
      fatal_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_alert.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : edn_reg_alert_test

  class edn_reg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(edn_reg_regwen)

    function new(string       name = "edn_reg_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("W0C");
    endfunction : build
  endclass : edn_reg_regwen

  class edn_reg_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field edn_enable;
    rand dv_base_reg_field boot_req_mode;
    rand dv_base_reg_field auto_req_mode;
    rand dv_base_reg_field cmd_fifo_rst;

    `uvm_object_utils(edn_reg_ctrl)

    function new(string       name = "edn_reg_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      edn_enable =
          (dv_base_reg_field::
           type_id::create("edn_enable"));
      edn_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_enable.set_original_access("RW");
      edn_enable.set_mubi_width(4);
      boot_req_mode =
          (dv_base_reg_field::
           type_id::create("boot_req_mode"));
      boot_req_mode.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_req_mode.set_original_access("RW");
      boot_req_mode.set_mubi_width(4);
      auto_req_mode =
          (dv_base_reg_field::
           type_id::create("auto_req_mode"));
      auto_req_mode.configure(
        .parent(this),
        .size(4),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auto_req_mode.set_original_access("RW");
      auto_req_mode.set_mubi_width(4);
      cmd_fifo_rst =
          (dv_base_reg_field::
           type_id::create("cmd_fifo_rst"));
      cmd_fifo_rst.configure(
        .parent(this),
        .size(4),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_fifo_rst.set_original_access("RW");
      cmd_fifo_rst.set_mubi_width(4);
    endfunction : build
  endclass : edn_reg_ctrl

  class edn_reg_boot_ins_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field boot_ins_cmd;

    `uvm_object_utils(edn_reg_boot_ins_cmd)

    function new(string       name = "edn_reg_boot_ins_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      boot_ins_cmd =
          (dv_base_reg_field::
           type_id::create("boot_ins_cmd"));
      boot_ins_cmd.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h901),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_ins_cmd.set_original_access("RW");
    endfunction : build
  endclass : edn_reg_boot_ins_cmd

  class edn_reg_boot_gen_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field boot_gen_cmd;

    `uvm_object_utils(edn_reg_boot_gen_cmd)

    function new(string       name = "edn_reg_boot_gen_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      boot_gen_cmd =
          (dv_base_reg_field::
           type_id::create("boot_gen_cmd"));
      boot_gen_cmd.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'hfff003),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_gen_cmd.set_original_access("RW");
    endfunction : build
  endclass : edn_reg_boot_gen_cmd

  class edn_reg_sw_cmd_req extends dv_base_reg;
    // fields
    rand dv_base_reg_field sw_cmd_req;

    `uvm_object_utils(edn_reg_sw_cmd_req)

    function new(string       name = "edn_reg_sw_cmd_req",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sw_cmd_req =
          (dv_base_reg_field::
           type_id::create("sw_cmd_req"));
      sw_cmd_req.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_cmd_req.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : edn_reg_sw_cmd_req

  class edn_reg_sw_cmd_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field cmd_reg_rdy;
    rand dv_base_reg_field cmd_rdy;
    rand dv_base_reg_field cmd_ack;
    rand dv_base_reg_field cmd_sts;

    `uvm_object_utils(edn_reg_sw_cmd_sts)

    function new(string       name = "edn_reg_sw_cmd_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cmd_reg_rdy =
          (dv_base_reg_field::
           type_id::create("cmd_reg_rdy"));
      cmd_reg_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_reg_rdy.set_original_access("RO");
      cmd_rdy =
          (dv_base_reg_field::
           type_id::create("cmd_rdy"));
      cmd_rdy.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_rdy.set_original_access("RO");
      cmd_ack =
          (dv_base_reg_field::
           type_id::create("cmd_ack"));
      cmd_ack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_ack.set_original_access("RO");
      cmd_sts =
          (dv_base_reg_field::
           type_id::create("cmd_sts"));
      cmd_sts.configure(
        .parent(this),
        .size(3),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_sts.set_original_access("RO");
    endfunction : build
  endclass : edn_reg_sw_cmd_sts

  class edn_reg_hw_cmd_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field boot_mode;
    rand dv_base_reg_field auto_mode;
    rand dv_base_reg_field cmd_type;
    rand dv_base_reg_field cmd_ack;
    rand dv_base_reg_field cmd_sts;

    `uvm_object_utils(edn_reg_hw_cmd_sts)

    function new(string       name = "edn_reg_hw_cmd_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      boot_mode =
          (dv_base_reg_field::
           type_id::create("boot_mode"));
      boot_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_mode.set_original_access("RO");
      auto_mode =
          (dv_base_reg_field::
           type_id::create("auto_mode"));
      auto_mode.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auto_mode.set_original_access("RO");
      cmd_type =
          (dv_base_reg_field::
           type_id::create("cmd_type"));
      cmd_type.configure(
        .parent(this),
        .size(4),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_type.set_original_access("RO");
      cmd_ack =
          (dv_base_reg_field::
           type_id::create("cmd_ack"));
      cmd_ack.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_ack.set_original_access("RO");
      cmd_sts =
          (dv_base_reg_field::
           type_id::create("cmd_sts"));
      cmd_sts.configure(
        .parent(this),
        .size(3),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_sts.set_original_access("RO");
    endfunction : build
  endclass : edn_reg_hw_cmd_sts

  class edn_reg_reseed_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field reseed_cmd;

    `uvm_object_utils(edn_reg_reseed_cmd)

    function new(string       name = "edn_reg_reseed_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      reseed_cmd =
          (dv_base_reg_field::
           type_id::create("reseed_cmd"));
      reseed_cmd.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      reseed_cmd.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : edn_reg_reseed_cmd

  class edn_reg_generate_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field generate_cmd;

    `uvm_object_utils(edn_reg_generate_cmd)

    function new(string       name = "edn_reg_generate_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      generate_cmd =
          (dv_base_reg_field::
           type_id::create("generate_cmd"));
      generate_cmd.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      generate_cmd.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : edn_reg_generate_cmd

  class edn_reg_max_num_reqs_between_reseeds extends dv_base_reg;
    // fields
    rand dv_base_reg_field max_num_reqs_between_reseeds;

    `uvm_object_utils(edn_reg_max_num_reqs_between_reseeds)

    function new(string       name = "edn_reg_max_num_reqs_between_reseeds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      max_num_reqs_between_reseeds =
          (dv_base_reg_field::
           type_id::create("max_num_reqs_between_reseeds"));
      max_num_reqs_between_reseeds.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      max_num_reqs_between_reseeds.set_original_access("RW");
    endfunction : build
  endclass : edn_reg_max_num_reqs_between_reseeds

  class edn_reg_recov_alert_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field edn_enable_field_alert;
    rand dv_base_reg_field boot_req_mode_field_alert;
    rand dv_base_reg_field auto_req_mode_field_alert;
    rand dv_base_reg_field cmd_fifo_rst_field_alert;
    rand dv_base_reg_field edn_bus_cmp_alert;
    rand dv_base_reg_field csrng_ack_err;

    `uvm_object_utils(edn_reg_recov_alert_sts)

    function new(string       name = "edn_reg_recov_alert_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      edn_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("edn_enable_field_alert"));
      edn_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_enable_field_alert.set_original_access("W0C");
      boot_req_mode_field_alert =
          (dv_base_reg_field::
           type_id::create("boot_req_mode_field_alert"));
      boot_req_mode_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      boot_req_mode_field_alert.set_original_access("W0C");
      auto_req_mode_field_alert =
          (dv_base_reg_field::
           type_id::create("auto_req_mode_field_alert"));
      auto_req_mode_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      auto_req_mode_field_alert.set_original_access("W0C");
      cmd_fifo_rst_field_alert =
          (dv_base_reg_field::
           type_id::create("cmd_fifo_rst_field_alert"));
      cmd_fifo_rst_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cmd_fifo_rst_field_alert.set_original_access("W0C");
      edn_bus_cmp_alert =
          (dv_base_reg_field::
           type_id::create("edn_bus_cmp_alert"));
      edn_bus_cmp_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_bus_cmp_alert.set_original_access("W0C");
      csrng_ack_err =
          (dv_base_reg_field::
           type_id::create("csrng_ack_err"));
      csrng_ack_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      csrng_ack_err.set_original_access("W0C");
    endfunction : build
  endclass : edn_reg_recov_alert_sts

  class edn_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field sfifo_rescmd_err;
    rand dv_base_reg_field sfifo_gencmd_err;
    rand dv_base_reg_field edn_ack_sm_err;
    rand dv_base_reg_field edn_main_sm_err;
    rand dv_base_reg_field edn_cntr_err;
    rand dv_base_reg_field fifo_write_err;
    rand dv_base_reg_field fifo_read_err;
    rand dv_base_reg_field fifo_state_err;

    `uvm_object_utils(edn_reg_err_code)

    function new(string       name = "edn_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sfifo_rescmd_err =
          (dv_base_reg_field::
           type_id::create("sfifo_rescmd_err"));
      sfifo_rescmd_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_rescmd_err.set_original_access("RO");
      sfifo_gencmd_err =
          (dv_base_reg_field::
           type_id::create("sfifo_gencmd_err"));
      sfifo_gencmd_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_gencmd_err.set_original_access("RO");
      edn_ack_sm_err =
          (dv_base_reg_field::
           type_id::create("edn_ack_sm_err"));
      edn_ack_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_ack_sm_err.set_original_access("RO");
      edn_main_sm_err =
          (dv_base_reg_field::
           type_id::create("edn_main_sm_err"));
      edn_main_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_main_sm_err.set_original_access("RO");
      edn_cntr_err =
          (dv_base_reg_field::
           type_id::create("edn_cntr_err"));
      edn_cntr_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      edn_cntr_err.set_original_access("RO");
      fifo_write_err =
          (dv_base_reg_field::
           type_id::create("fifo_write_err"));
      fifo_write_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_write_err.set_original_access("RO");
      fifo_read_err =
          (dv_base_reg_field::
           type_id::create("fifo_read_err"));
      fifo_read_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_read_err.set_original_access("RO");
      fifo_state_err =
          (dv_base_reg_field::
           type_id::create("fifo_state_err"));
      fifo_state_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_state_err.set_original_access("RO");
    endfunction : build
  endclass : edn_reg_err_code

  class edn_reg_err_code_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_code_test;

    `uvm_object_utils(edn_reg_err_code_test)

    function new(string       name = "edn_reg_err_code_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      err_code_test =
          (dv_base_reg_field::
           type_id::create("err_code_test"));
      err_code_test.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_code_test.set_original_access("RW");
    endfunction : build
  endclass : edn_reg_err_code_test

  class edn_reg_main_sm_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field main_sm_state;

    `uvm_object_utils(edn_reg_main_sm_state)

    function new(string       name = "edn_reg_main_sm_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      main_sm_state =
          (dv_base_reg_field::
           type_id::create("main_sm_state"));
      main_sm_state.configure(
        .parent(this),
        .size(9),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hc1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_state.set_original_access("RO");
    endfunction : build
  endclass : edn_reg_main_sm_state

  class edn_reg_block extends dv_base_reg_block;
    // registers
    rand edn_reg_intr_state intr_state;
    rand edn_reg_intr_enable intr_enable;
    rand edn_reg_intr_test intr_test;
    rand edn_reg_alert_test alert_test;
    rand edn_reg_regwen regwen;
    rand edn_reg_ctrl ctrl;
    rand edn_reg_boot_ins_cmd boot_ins_cmd;
    rand edn_reg_boot_gen_cmd boot_gen_cmd;
    rand edn_reg_sw_cmd_req sw_cmd_req;
    rand edn_reg_sw_cmd_sts sw_cmd_sts;
    rand edn_reg_hw_cmd_sts hw_cmd_sts;
    rand edn_reg_reseed_cmd reseed_cmd;
    rand edn_reg_generate_cmd generate_cmd;
    rand edn_reg_max_num_reqs_between_reseeds max_num_reqs_between_reseeds;
    rand edn_reg_recov_alert_sts recov_alert_sts;
    rand edn_reg_err_code err_code;
    rand edn_reg_err_code_test err_code_test;
    rand edn_reg_main_sm_state main_sm_state;

    `uvm_object_utils(edn_reg_block)

    function new(string name = "edn_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (edn_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_edn_cmd_req_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_edn_fatal_err.q",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (edn_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_edn_cmd_req_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_edn_fatal_err.q",
          1, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (edn_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_edn_cmd_req_done.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_edn_fatal_err.qs",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (edn_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_alert.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_alert.qs",
          1, 1, 0, "BkdrRegPathRtl");

      regwen =
          (edn_reg_regwen::
           type_id::create("regwen"));
      regwen.configure(.blk_parent(this));
      regwen.build(csr_excl);
      default_map.add_reg(.rg(regwen),
                          .offset(32'h10));
      regwen.add_hdl_path_slice(
          "u_reg.u_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      ctrl =
          (edn_reg_ctrl::
           type_id::create("ctrl"));
      ctrl.configure(.blk_parent(this));
      ctrl.build(csr_excl);
      default_map.add_reg(.rg(ctrl),
                          .offset(32'h14));
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_edn_enable.q",
          0, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_boot_req_mode.q",
          4, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_auto_req_mode.q",
          8, 4, 0, "BkdrRegPathRtl");
      ctrl.add_hdl_path_slice(
          "u_reg.u_ctrl_cmd_fifo_rst.q",
          12, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(ctrl.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      boot_ins_cmd =
          (edn_reg_boot_ins_cmd::
           type_id::create("boot_ins_cmd"));
      boot_ins_cmd.configure(.blk_parent(this));
      boot_ins_cmd.build(csr_excl);
      default_map.add_reg(.rg(boot_ins_cmd),
                          .offset(32'h18));
      boot_ins_cmd.add_hdl_path_slice(
          "u_reg.u_boot_ins_cmd.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(boot_ins_cmd.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      boot_gen_cmd =
          (edn_reg_boot_gen_cmd::
           type_id::create("boot_gen_cmd"));
      boot_gen_cmd.configure(.blk_parent(this));
      boot_gen_cmd.build(csr_excl);
      default_map.add_reg(.rg(boot_gen_cmd),
                          .offset(32'h1c));
      boot_gen_cmd.add_hdl_path_slice(
          "u_reg.u_boot_gen_cmd.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(boot_gen_cmd.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      sw_cmd_req =
          (edn_reg_sw_cmd_req::
           type_id::create("sw_cmd_req"));
      sw_cmd_req.configure(.blk_parent(this));
      sw_cmd_req.build(csr_excl);
      default_map.add_reg(.rg(sw_cmd_req),
                          .offset(32'h20));
      sw_cmd_req.add_hdl_path_slice(
          "u_reg.u_sw_cmd_req.qs",
          0, 32, 0, "BkdrRegPathRtl");

      sw_cmd_sts =
          (edn_reg_sw_cmd_sts::
           type_id::create("sw_cmd_sts"));
      sw_cmd_sts.configure(.blk_parent(this));
      sw_cmd_sts.build(csr_excl);
      default_map.add_reg(.rg(sw_cmd_sts),
                          .offset(32'h24));
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_reg_rdy.q",
          0, 1, 0, "BkdrRegPathRtl");
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_rdy.q",
          1, 1, 0, "BkdrRegPathRtl");
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_ack.q",
          2, 1, 0, "BkdrRegPathRtl");
      sw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_sw_cmd_sts_cmd_sts.q",
          3, 3, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_cmd_sts.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      hw_cmd_sts =
          (edn_reg_hw_cmd_sts::
           type_id::create("hw_cmd_sts"));
      hw_cmd_sts.configure(.blk_parent(this));
      hw_cmd_sts.build(csr_excl);
      default_map.add_reg(.rg(hw_cmd_sts),
                          .offset(32'h28));
      hw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_hw_cmd_sts_boot_mode.q",
          0, 1, 0, "BkdrRegPathRtl");
      hw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_hw_cmd_sts_auto_mode.q",
          1, 1, 0, "BkdrRegPathRtl");
      hw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_hw_cmd_sts_cmd_type.q",
          2, 4, 0, "BkdrRegPathRtl");
      hw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_hw_cmd_sts_cmd_ack.q",
          6, 1, 0, "BkdrRegPathRtl");
      hw_cmd_sts.add_hdl_path_slice(
          "u_reg.u_hw_cmd_sts_cmd_sts.q",
          7, 3, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(hw_cmd_sts.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      reseed_cmd =
          (edn_reg_reseed_cmd::
           type_id::create("reseed_cmd"));
      reseed_cmd.configure(.blk_parent(this));
      reseed_cmd.build(csr_excl);
      default_map.add_reg(.rg(reseed_cmd),
                          .offset(32'h2c));
      reseed_cmd.add_hdl_path_slice(
          "u_reg.u_reseed_cmd.qs",
          0, 32, 0, "BkdrRegPathRtl");

      generate_cmd =
          (edn_reg_generate_cmd::
           type_id::create("generate_cmd"));
      generate_cmd.configure(.blk_parent(this));
      generate_cmd.build(csr_excl);
      default_map.add_reg(.rg(generate_cmd),
                          .offset(32'h30));
      generate_cmd.add_hdl_path_slice(
          "u_reg.u_generate_cmd.qs",
          0, 32, 0, "BkdrRegPathRtl");

      max_num_reqs_between_reseeds =
          (edn_reg_max_num_reqs_between_reseeds::
           type_id::create("max_num_reqs_between_reseeds"));
      max_num_reqs_between_reseeds.configure(.blk_parent(this));
      max_num_reqs_between_reseeds.build(csr_excl);
      default_map.add_reg(.rg(max_num_reqs_between_reseeds),
                          .offset(32'h34));
      max_num_reqs_between_reseeds.add_hdl_path_slice(
          "u_reg.u_max_num_reqs_between_reseeds.q",
          0, 32, 0, "BkdrRegPathRtl");

      recov_alert_sts =
          (edn_reg_recov_alert_sts::
           type_id::create("recov_alert_sts"));
      recov_alert_sts.configure(.blk_parent(this));
      recov_alert_sts.build(csr_excl);
      default_map.add_reg(.rg(recov_alert_sts),
                          .offset(32'h38));
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_edn_enable_field_alert.q",
          0, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_boot_req_mode_field_alert.q",
          1, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_auto_req_mode_field_alert.q",
          2, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_cmd_fifo_rst_field_alert.q",
          3, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_edn_bus_cmp_alert.q",
          12, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_csrng_ack_err.q",
          13, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(recov_alert_sts.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      err_code =
          (edn_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'h3c));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_rescmd_err.q",
          0, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_gencmd_err.q",
          1, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_edn_ack_sm_err.q",
          20, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_edn_main_sm_err.q",
          21, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_edn_cntr_err.q",
          22, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_write_err.q",
          28, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_read_err.q",
          29, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_state_err.q",
          30, 1, 0, "BkdrRegPathRtl");

      err_code_test =
          (edn_reg_err_code_test::
           type_id::create("err_code_test"));
      err_code_test.configure(.blk_parent(this));
      err_code_test.build(csr_excl);
      default_map.add_reg(.rg(err_code_test),
                          .offset(32'h40));
      err_code_test.add_hdl_path_slice(
          "u_reg.u_err_code_test.q",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(err_code_test.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      main_sm_state =
          (edn_reg_main_sm_state::
           type_id::create("main_sm_state"));
      main_sm_state.configure(.blk_parent(this));
      main_sm_state.build(csr_excl);
      default_map.add_reg(.rg(main_sm_state),
                          .offset(32'h44));
      main_sm_state.add_hdl_path_slice(
          "u_reg.u_main_sm_state.q",
          0, 9, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      regwen.add_lockable_reg_or_fld(ctrl);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : edn_reg_block

endpackage

