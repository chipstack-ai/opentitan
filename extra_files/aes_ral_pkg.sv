// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package aes_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class aes_reg_alert_test;
  typedef class aes_reg_key_share0;
  typedef class aes_reg_key_share1;
  typedef class aes_reg_iv;
  typedef class aes_reg_data_in;
  typedef class aes_reg_data_out;
  typedef class aes_reg_ctrl_shadowed;
  typedef class aes_reg_ctrl_aux_shadowed;
  typedef class aes_reg_ctrl_aux_regwen;
  typedef class aes_reg_trigger;
  typedef class aes_reg_status;
  typedef class aes_reg_block;

  class aes_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_ctrl_update_err;
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(aes_reg_alert_test)

    function new(string       name = "aes_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_ctrl_update_err =
          (dv_base_reg_field::
           type_id::create("recov_ctrl_update_err"));
      recov_ctrl_update_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_ctrl_update_err.set_original_access("WO");
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_alert_test

  class aes_reg_key_share0 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key_share0;

    `uvm_object_utils(aes_reg_key_share0)

    function new(string       name = "aes_reg_key_share0",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key_share0 =
          (dv_base_reg_field::
           type_id::create("key_share0_0"));
      key_share0.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_share0.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_key_share0

  class aes_reg_key_share1 extends dv_base_reg;
    // fields
    rand dv_base_reg_field key_share1;

    `uvm_object_utils(aes_reg_key_share1)

    function new(string       name = "aes_reg_key_share1",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key_share1 =
          (dv_base_reg_field::
           type_id::create("key_share1_0"));
      key_share1.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_share1.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_key_share1

  class aes_reg_iv extends dv_base_reg;
    // fields
    rand dv_base_reg_field iv;

    `uvm_object_utils(aes_reg_iv)

    function new(string       name = "aes_reg_iv",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      iv =
          (dv_base_reg_field::
           type_id::create("iv_0"));
      iv.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      iv.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_iv

  class aes_reg_data_in extends dv_base_reg;
    // fields
    rand dv_base_reg_field data_in;

    `uvm_object_utils(aes_reg_data_in)

    function new(string       name = "aes_reg_data_in",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data_in =
          (dv_base_reg_field::
           type_id::create("data_in_0"));
      data_in.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_in.set_original_access("WO");
    endfunction : build
  endclass : aes_reg_data_in

  class aes_reg_data_out extends dv_base_reg;
    // fields
    rand dv_base_reg_field data_out;

    `uvm_object_utils(aes_reg_data_out)

    function new(string       name = "aes_reg_data_out",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      data_out =
          (dv_base_reg_field::
           type_id::create("data_out_0"));
      data_out.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_out.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_data_out

  class aes_reg_ctrl_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field operation;
    rand dv_base_reg_field mode;
    rand dv_base_reg_field key_len;
    rand dv_base_reg_field sideload;
    rand dv_base_reg_field prng_reseed_rate;
    rand dv_base_reg_field manual_operation;

    `uvm_object_utils(aes_reg_ctrl_shadowed)

    function new(string       name = "aes_reg_ctrl_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      operation =
          (dv_base_reg_field::
           type_id::create("operation"));
      operation.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      operation.set_original_access("RW");
      // create field tags
      mode =
          (dv_base_reg_field::
           type_id::create("mode"));
      mode.configure(
        .parent(this),
        .size(6),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h20),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      mode.set_original_access("RW");
      // create field tags
      key_len =
          (dv_base_reg_field::
           type_id::create("key_len"));
      key_len.configure(
        .parent(this),
        .size(3),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_len.set_original_access("RW");
      // create field tags
      sideload =
          (dv_base_reg_field::
           type_id::create("sideload"));
      sideload.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sideload.set_original_access("RW");
      // create field tags
      prng_reseed_rate =
          (dv_base_reg_field::
           type_id::create("prng_reseed_rate"));
      prng_reseed_rate.configure(
        .parent(this),
        .size(3),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prng_reseed_rate.set_original_access("RW");
      // create field tags
      manual_operation =
          (dv_base_reg_field::
           type_id::create("manual_operation"));
      manual_operation.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      manual_operation.set_original_access("RW");
      // create field tags
      set_is_ext_reg(1);
    endfunction : build
  endclass : aes_reg_ctrl_shadowed

  class aes_reg_ctrl_aux_shadowed extends dv_base_reg;
    // fields
    rand dv_base_reg_field key_touch_forces_reseed;
    rand dv_base_reg_field force_masks;

    `uvm_object_utils(aes_reg_ctrl_aux_shadowed)

    function new(string       name = "aes_reg_ctrl_aux_shadowed",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key_touch_forces_reseed =
          (dv_base_reg_field::
           type_id::create("key_touch_forces_reseed"));
      key_touch_forces_reseed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_touch_forces_reseed.set_original_access("RW");
      force_masks =
          (dv_base_reg_field::
           type_id::create("force_masks"));
      force_masks.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      force_masks.set_original_access("RW");
    endfunction : build
  endclass : aes_reg_ctrl_aux_shadowed

  class aes_reg_ctrl_aux_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field ctrl_aux_regwen;

    `uvm_object_utils(aes_reg_ctrl_aux_regwen)

    function new(string       name = "aes_reg_ctrl_aux_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      ctrl_aux_regwen =
          (dv_base_reg_field::
           type_id::create("ctrl_aux_regwen"));
      ctrl_aux_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      ctrl_aux_regwen.set_original_access("W0C");
    endfunction : build
  endclass : aes_reg_ctrl_aux_regwen

  class aes_reg_trigger extends dv_base_reg;
    // fields
    rand dv_base_reg_field start;
    rand dv_base_reg_field key_iv_data_in_clear;
    rand dv_base_reg_field data_out_clear;
    rand dv_base_reg_field prng_reseed;

    `uvm_object_utils(aes_reg_trigger)

    function new(string       name = "aes_reg_trigger",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      start =
          (dv_base_reg_field::
           type_id::create("start"));
      start.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      start.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(start.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
      key_iv_data_in_clear =
          (dv_base_reg_field::
           type_id::create("key_iv_data_in_clear"));
      key_iv_data_in_clear.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_iv_data_in_clear.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(key_iv_data_in_clear.get_full_name(), CsrExclCheck, CsrAllTests);
      data_out_clear =
          (dv_base_reg_field::
           type_id::create("data_out_clear"));
      data_out_clear.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      data_out_clear.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(data_out_clear.get_full_name(), CsrExclCheck, CsrAllTests);
      prng_reseed =
          (dv_base_reg_field::
           type_id::create("prng_reseed"));
      prng_reseed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prng_reseed.set_original_access("WO");
      // create field tags
      csr_excl.add_excl(prng_reseed.get_full_name(), CsrExclCheck, CsrAllTests);
    endfunction : build
  endclass : aes_reg_trigger

  class aes_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field idle;
    rand dv_base_reg_field stall;
    rand dv_base_reg_field output_lost;
    rand dv_base_reg_field output_valid;
    rand dv_base_reg_field input_ready;
    rand dv_base_reg_field alert_recov_ctrl_update_err;
    rand dv_base_reg_field alert_fatal_fault;

    `uvm_object_utils(aes_reg_status)

    function new(string       name = "aes_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      idle =
          (dv_base_reg_field::
           type_id::create("idle"));
      idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      idle.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(idle.get_full_name(), CsrExclCheck, CsrAllTests);
      stall =
          (dv_base_reg_field::
           type_id::create("stall"));
      stall.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      stall.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(stall.get_full_name(), CsrExclCheck, CsrNonInitTests);
      output_lost =
          (dv_base_reg_field::
           type_id::create("output_lost"));
      output_lost.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      output_lost.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(output_lost.get_full_name(), CsrExclCheck, CsrNonInitTests);
      output_valid =
          (dv_base_reg_field::
           type_id::create("output_valid"));
      output_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      output_valid.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(output_valid.get_full_name(), CsrExclCheck, CsrNonInitTests);
      input_ready =
          (dv_base_reg_field::
           type_id::create("input_ready"));
      input_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      input_ready.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(input_ready.get_full_name(), CsrExclCheck, CsrAllTests);
      alert_recov_ctrl_update_err =
          (dv_base_reg_field::
           type_id::create("alert_recov_ctrl_update_err"));
      alert_recov_ctrl_update_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_recov_ctrl_update_err.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(alert_recov_ctrl_update_err.get_full_name(), CsrExclCheck, CsrNonInitTests);
      alert_fatal_fault =
          (dv_base_reg_field::
           type_id::create("alert_fatal_fault"));
      alert_fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_fatal_fault.set_original_access("RO");
    endfunction : build
  endclass : aes_reg_status

  class aes_reg_block extends dv_base_reg_block;
    // registers
    rand aes_reg_alert_test alert_test;
    rand aes_reg_key_share0 key_share0[8];
    rand aes_reg_key_share1 key_share1[8];
    rand aes_reg_iv iv[4];
    rand aes_reg_data_in data_in[4];
    rand aes_reg_data_out data_out[4];
    rand aes_reg_ctrl_shadowed ctrl_shadowed;
    rand aes_reg_ctrl_aux_shadowed ctrl_aux_shadowed;
    rand aes_reg_ctrl_aux_regwen ctrl_aux_regwen;
    rand aes_reg_trigger trigger;
    rand aes_reg_status status;

    `uvm_object_utils(aes_reg_block)

    function new(string name = "aes_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (aes_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_ctrl_update_err.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_fault.qs",
          1, 1, 0, "BkdrRegPathRtl");

      key_share0[0] =
          (aes_reg_key_share0::
           type_id::create("key_share0_0"));
      key_share0[0].configure(.blk_parent(this));
      key_share0[0].build(csr_excl);
      default_map.add_reg(.rg(key_share0[0]),
                          .offset(32'h4));
      key_share0[0].add_hdl_path_slice(
          "u_reg.u_key_share0_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[0].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[1] =
          (aes_reg_key_share0::
           type_id::create("key_share0_1"));
      key_share0[1].configure(.blk_parent(this));
      key_share0[1].build(csr_excl);
      default_map.add_reg(.rg(key_share0[1]),
                          .offset(32'h8));
      key_share0[1].add_hdl_path_slice(
          "u_reg.u_key_share0_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[1].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[2] =
          (aes_reg_key_share0::
           type_id::create("key_share0_2"));
      key_share0[2].configure(.blk_parent(this));
      key_share0[2].build(csr_excl);
      default_map.add_reg(.rg(key_share0[2]),
                          .offset(32'hc));
      key_share0[2].add_hdl_path_slice(
          "u_reg.u_key_share0_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[2].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[3] =
          (aes_reg_key_share0::
           type_id::create("key_share0_3"));
      key_share0[3].configure(.blk_parent(this));
      key_share0[3].build(csr_excl);
      default_map.add_reg(.rg(key_share0[3]),
                          .offset(32'h10));
      key_share0[3].add_hdl_path_slice(
          "u_reg.u_key_share0_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[3].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[4] =
          (aes_reg_key_share0::
           type_id::create("key_share0_4"));
      key_share0[4].configure(.blk_parent(this));
      key_share0[4].build(csr_excl);
      default_map.add_reg(.rg(key_share0[4]),
                          .offset(32'h14));
      key_share0[4].add_hdl_path_slice(
          "u_reg.u_key_share0_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[4].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[5] =
          (aes_reg_key_share0::
           type_id::create("key_share0_5"));
      key_share0[5].configure(.blk_parent(this));
      key_share0[5].build(csr_excl);
      default_map.add_reg(.rg(key_share0[5]),
                          .offset(32'h18));
      key_share0[5].add_hdl_path_slice(
          "u_reg.u_key_share0_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[5].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[6] =
          (aes_reg_key_share0::
           type_id::create("key_share0_6"));
      key_share0[6].configure(.blk_parent(this));
      key_share0[6].build(csr_excl);
      default_map.add_reg(.rg(key_share0[6]),
                          .offset(32'h1c));
      key_share0[6].add_hdl_path_slice(
          "u_reg.u_key_share0_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[6].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share0[7] =
          (aes_reg_key_share0::
           type_id::create("key_share0_7"));
      key_share0[7].configure(.blk_parent(this));
      key_share0[7].build(csr_excl);
      default_map.add_reg(.rg(key_share0[7]),
                          .offset(32'h20));
      key_share0[7].add_hdl_path_slice(
          "u_reg.u_key_share0_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share0[7].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[0] =
          (aes_reg_key_share1::
           type_id::create("key_share1_0"));
      key_share1[0].configure(.blk_parent(this));
      key_share1[0].build(csr_excl);
      default_map.add_reg(.rg(key_share1[0]),
                          .offset(32'h24));
      key_share1[0].add_hdl_path_slice(
          "u_reg.u_key_share1_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[0].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[1] =
          (aes_reg_key_share1::
           type_id::create("key_share1_1"));
      key_share1[1].configure(.blk_parent(this));
      key_share1[1].build(csr_excl);
      default_map.add_reg(.rg(key_share1[1]),
                          .offset(32'h28));
      key_share1[1].add_hdl_path_slice(
          "u_reg.u_key_share1_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[1].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[2] =
          (aes_reg_key_share1::
           type_id::create("key_share1_2"));
      key_share1[2].configure(.blk_parent(this));
      key_share1[2].build(csr_excl);
      default_map.add_reg(.rg(key_share1[2]),
                          .offset(32'h2c));
      key_share1[2].add_hdl_path_slice(
          "u_reg.u_key_share1_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[2].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[3] =
          (aes_reg_key_share1::
           type_id::create("key_share1_3"));
      key_share1[3].configure(.blk_parent(this));
      key_share1[3].build(csr_excl);
      default_map.add_reg(.rg(key_share1[3]),
                          .offset(32'h30));
      key_share1[3].add_hdl_path_slice(
          "u_reg.u_key_share1_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[3].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[4] =
          (aes_reg_key_share1::
           type_id::create("key_share1_4"));
      key_share1[4].configure(.blk_parent(this));
      key_share1[4].build(csr_excl);
      default_map.add_reg(.rg(key_share1[4]),
                          .offset(32'h34));
      key_share1[4].add_hdl_path_slice(
          "u_reg.u_key_share1_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[4].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[5] =
          (aes_reg_key_share1::
           type_id::create("key_share1_5"));
      key_share1[5].configure(.blk_parent(this));
      key_share1[5].build(csr_excl);
      default_map.add_reg(.rg(key_share1[5]),
                          .offset(32'h38));
      key_share1[5].add_hdl_path_slice(
          "u_reg.u_key_share1_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[5].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[6] =
          (aes_reg_key_share1::
           type_id::create("key_share1_6"));
      key_share1[6].configure(.blk_parent(this));
      key_share1[6].build(csr_excl);
      default_map.add_reg(.rg(key_share1[6]),
                          .offset(32'h3c));
      key_share1[6].add_hdl_path_slice(
          "u_reg.u_key_share1_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[6].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      key_share1[7] =
          (aes_reg_key_share1::
           type_id::create("key_share1_7"));
      key_share1[7].configure(.blk_parent(this));
      key_share1[7].build(csr_excl);
      default_map.add_reg(.rg(key_share1[7]),
                          .offset(32'h40));
      key_share1[7].add_hdl_path_slice(
          "u_reg.u_key_share1_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(key_share1[7].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      iv[0] =
          (aes_reg_iv::
           type_id::create("iv_0"));
      iv[0].configure(.blk_parent(this));
      iv[0].build(csr_excl);
      default_map.add_reg(.rg(iv[0]),
                          .offset(32'h44));
      iv[0].add_hdl_path_slice(
          "u_reg.u_iv_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(iv[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      iv[1] =
          (aes_reg_iv::
           type_id::create("iv_1"));
      iv[1].configure(.blk_parent(this));
      iv[1].build(csr_excl);
      default_map.add_reg(.rg(iv[1]),
                          .offset(32'h48));
      iv[1].add_hdl_path_slice(
          "u_reg.u_iv_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(iv[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      iv[2] =
          (aes_reg_iv::
           type_id::create("iv_2"));
      iv[2].configure(.blk_parent(this));
      iv[2].build(csr_excl);
      default_map.add_reg(.rg(iv[2]),
                          .offset(32'h4c));
      iv[2].add_hdl_path_slice(
          "u_reg.u_iv_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(iv[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      iv[3] =
          (aes_reg_iv::
           type_id::create("iv_3"));
      iv[3].configure(.blk_parent(this));
      iv[3].build(csr_excl);
      default_map.add_reg(.rg(iv[3]),
                          .offset(32'h50));
      iv[3].add_hdl_path_slice(
          "u_reg.u_iv_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(iv[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      data_in[0] =
          (aes_reg_data_in::
           type_id::create("data_in_0"));
      data_in[0].configure(.blk_parent(this));
      data_in[0].build(csr_excl);
      default_map.add_reg(.rg(data_in[0]),
                          .offset(32'h54));
      data_in[0].add_hdl_path_slice(
          "u_reg.u_data_in_0.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_in[0].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      data_in[1] =
          (aes_reg_data_in::
           type_id::create("data_in_1"));
      data_in[1].configure(.blk_parent(this));
      data_in[1].build(csr_excl);
      default_map.add_reg(.rg(data_in[1]),
                          .offset(32'h58));
      data_in[1].add_hdl_path_slice(
          "u_reg.u_data_in_1.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_in[1].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      data_in[2] =
          (aes_reg_data_in::
           type_id::create("data_in_2"));
      data_in[2].configure(.blk_parent(this));
      data_in[2].build(csr_excl);
      default_map.add_reg(.rg(data_in[2]),
                          .offset(32'h5c));
      data_in[2].add_hdl_path_slice(
          "u_reg.u_data_in_2.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_in[2].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      data_in[3] =
          (aes_reg_data_in::
           type_id::create("data_in_3"));
      data_in[3].configure(.blk_parent(this));
      data_in[3].build(csr_excl);
      default_map.add_reg(.rg(data_in[3]),
                          .offset(32'h60));
      data_in[3].add_hdl_path_slice(
          "u_reg.u_data_in_3.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_in[3].get_full_name(),
                        CsrExclCheck, CsrHwResetTest);
      data_out[0] =
          (aes_reg_data_out::
           type_id::create("data_out_0"));
      data_out[0].configure(.blk_parent(this));
      data_out[0].build(csr_excl);
      default_map.add_reg(.rg(data_out[0]),
                          .offset(32'h64));
      data_out[0].add_hdl_path_slice(
          "u_reg.u_data_out_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_out[0].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      data_out[1] =
          (aes_reg_data_out::
           type_id::create("data_out_1"));
      data_out[1].configure(.blk_parent(this));
      data_out[1].build(csr_excl);
      default_map.add_reg(.rg(data_out[1]),
                          .offset(32'h68));
      data_out[1].add_hdl_path_slice(
          "u_reg.u_data_out_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_out[1].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      data_out[2] =
          (aes_reg_data_out::
           type_id::create("data_out_2"));
      data_out[2].configure(.blk_parent(this));
      data_out[2].build(csr_excl);
      default_map.add_reg(.rg(data_out[2]),
                          .offset(32'h6c));
      data_out[2].add_hdl_path_slice(
          "u_reg.u_data_out_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_out[2].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      data_out[3] =
          (aes_reg_data_out::
           type_id::create("data_out_3"));
      data_out[3].configure(.blk_parent(this));
      data_out[3].build(csr_excl);
      default_map.add_reg(.rg(data_out[3]),
                          .offset(32'h70));
      data_out[3].add_hdl_path_slice(
          "u_reg.u_data_out_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(data_out[3].get_full_name(),
                        CsrExclCheck, CsrAllTests);
      ctrl_shadowed =
          (aes_reg_ctrl_shadowed::
           type_id::create("ctrl_shadowed"));
      ctrl_shadowed.configure(.blk_parent(this));
      ctrl_shadowed.build(csr_excl);
      default_map.add_reg(.rg(ctrl_shadowed),
                          .offset(32'h74));
      ctrl_shadowed.add_update_err_alert("recov_ctrl_update_err");

      ctrl_shadowed.add_storage_err_alert("fatal_fault");

      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_operation.committed_reg.q",
          0, 2, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_operation.shadow_reg.q",
          0, 2, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_mode.committed_reg.q",
          2, 6, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_mode.shadow_reg.q",
          2, 6, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_key_len.committed_reg.q",
          8, 3, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_key_len.shadow_reg.q",
          8, 3, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_sideload.committed_reg.q",
          11, 1, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_sideload.shadow_reg.q",
          11, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_prng_reseed_rate.committed_reg.q",
          12, 3, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_prng_reseed_rate.shadow_reg.q",
          12, 3, 0, "BkdrRegPathRtlShadow");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_manual_operation.committed_reg.q",
          15, 1, 0, "BkdrRegPathRtl");
      ctrl_shadowed.add_hdl_path_slice(
          "u_aes_core.u_ctrl_reg_shadowed.u_ctrl_reg_shadowed_manual_operation.shadow_reg.q",
          15, 1, 0, "BkdrRegPathRtlShadow");

      ctrl_shadowed.set_is_shadowed();
      // create register tags
      csr_excl.add_excl(ctrl_shadowed.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      ctrl_aux_shadowed =
          (aes_reg_ctrl_aux_shadowed::
           type_id::create("ctrl_aux_shadowed"));
      ctrl_aux_shadowed.configure(.blk_parent(this));
      ctrl_aux_shadowed.build(csr_excl);
      default_map.add_reg(.rg(ctrl_aux_shadowed),
                          .offset(32'h78));
      ctrl_aux_shadowed.add_update_err_alert("recov_ctrl_update_err");

      ctrl_aux_shadowed.add_storage_err_alert("fatal_fault");

      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_key_touch_forces_reseed.committed_reg.q",
          0, 1, 0, "BkdrRegPathRtl");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_key_touch_forces_reseed.shadow_reg.q",
          0, 1, 0, "BkdrRegPathRtlShadow");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_force_masks.committed_reg.q",
          1, 1, 0, "BkdrRegPathRtl");
      ctrl_aux_shadowed.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_shadowed_force_masks.shadow_reg.q",
          1, 1, 0, "BkdrRegPathRtlShadow");

      ctrl_aux_shadowed.set_is_shadowed();
      ctrl_aux_regwen =
          (aes_reg_ctrl_aux_regwen::
           type_id::create("ctrl_aux_regwen"));
      ctrl_aux_regwen.configure(.blk_parent(this));
      ctrl_aux_regwen.build(csr_excl);
      default_map.add_reg(.rg(ctrl_aux_regwen),
                          .offset(32'h7c));
      ctrl_aux_regwen.add_hdl_path_slice(
          "u_reg.u_ctrl_aux_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      trigger =
          (aes_reg_trigger::
           type_id::create("trigger"));
      trigger.configure(.blk_parent(this));
      trigger.build(csr_excl);
      default_map.add_reg(.rg(trigger),
                          .offset(32'h80));
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_start.q",
          0, 1, 0, "BkdrRegPathRtl");
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_key_iv_data_in_clear.q",
          1, 1, 0, "BkdrRegPathRtl");
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_data_out_clear.q",
          2, 1, 0, "BkdrRegPathRtl");
      trigger.add_hdl_path_slice(
          "u_reg.u_trigger_prng_reseed.q",
          3, 1, 0, "BkdrRegPathRtl");

      status =
          (aes_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h84));
      status.add_hdl_path_slice(
          "u_reg.u_status_idle.q",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_stall.q",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_output_lost.q",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_output_valid.q",
          3, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_input_ready.q",
          4, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_recov_ctrl_update_err.q",
          5, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_alert_fatal_fault.q",
          6, 1, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      ctrl_aux_regwen.add_lockable_reg_or_fld(ctrl_aux_shadowed);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : aes_reg_block

endpackage

