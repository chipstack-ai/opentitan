// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package hmac_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class hmac_reg_intr_state;
  typedef class hmac_reg_intr_enable;
  typedef class hmac_reg_intr_test;
  typedef class hmac_reg_alert_test;
  typedef class hmac_reg_cfg;
  typedef class hmac_reg_cmd;
  typedef class hmac_reg_status;
  typedef class hmac_reg_err_code;
  typedef class hmac_reg_wipe_secret;
  typedef class hmac_reg_key;
  typedef class hmac_reg_digest;
  typedef class hmac_reg_msg_length_lower;
  typedef class hmac_reg_msg_length_upper;
  typedef class hmac_mem_msg_fifo;
  typedef class hmac_reg_block;

  class hmac_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field hmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field hmac_err;

    `uvm_object_utils(hmac_reg_intr_state)

    function new(string       name = "hmac_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hmac_done =
          (dv_base_reg_field::
           type_id::create("hmac_done"));
      hmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_done.set_original_access("W1C");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RO");
      hmac_err =
          (dv_base_reg_field::
           type_id::create("hmac_err"));
      hmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_err.set_original_access("W1C");
    endfunction : build
  endclass : hmac_reg_intr_state

  class hmac_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field hmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field hmac_err;

    `uvm_object_utils(hmac_reg_intr_enable)

    function new(string       name = "hmac_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hmac_done =
          (dv_base_reg_field::
           type_id::create("hmac_done"));
      hmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_done.set_original_access("RW");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RW");
      hmac_err =
          (dv_base_reg_field::
           type_id::create("hmac_err"));
      hmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_err.set_original_access("RW");
    endfunction : build
  endclass : hmac_reg_intr_enable

  class hmac_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field hmac_done;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field hmac_err;

    `uvm_object_utils(hmac_reg_intr_test)

    function new(string       name = "hmac_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hmac_done =
          (dv_base_reg_field::
           type_id::create("hmac_done"));
      hmac_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_done.set_original_access("WO");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("WO");
      hmac_err =
          (dv_base_reg_field::
           type_id::create("hmac_err"));
      hmac_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_intr_test

  class hmac_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(hmac_reg_alert_test)

    function new(string       name = "hmac_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_alert_test

  class hmac_reg_cfg extends dv_base_reg;
    // fields
    rand dv_base_reg_field hmac_en;
    rand dv_base_reg_field sha_en;
    rand dv_base_reg_field endian_swap;
    rand dv_base_reg_field digest_swap;
    rand dv_base_reg_field key_swap;
    rand dv_base_reg_field digest_size;
    rand dv_base_reg_field key_length;

    `uvm_object_utils(hmac_reg_cfg)

    function new(string       name = "hmac_reg_cfg",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hmac_en =
          (dv_base_reg_field::
           type_id::create("hmac_en"));
      hmac_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(hmac_en.get_full_name(), CsrExclWrite, CsrNonInitTests);
      sha_en =
          (dv_base_reg_field::
           type_id::create("sha_en"));
      sha_en.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha_en.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(sha_en.get_full_name(), CsrExclWrite, CsrNonInitTests);
      endian_swap =
          (dv_base_reg_field::
           type_id::create("endian_swap"));
      endian_swap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      endian_swap.set_original_access("RW");
      digest_swap =
          (dv_base_reg_field::
           type_id::create("digest_swap"));
      digest_swap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest_swap.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(digest_swap.get_full_name(), CsrExclWrite, CsrAllTests);
      key_swap =
          (dv_base_reg_field::
           type_id::create("key_swap"));
      key_swap.configure(
        .parent(this),
        .size(1),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_swap.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(key_swap.get_full_name(), CsrExclWrite, CsrAllTests);
      digest_size =
          (dv_base_reg_field::
           type_id::create("digest_size"));
      digest_size.configure(
        .parent(this),
        .size(4),
        .lsb_pos(5),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h8),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest_size.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(digest_size.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
      key_length =
          (dv_base_reg_field::
           type_id::create("key_length"));
      key_length.configure(
        .parent(this),
        .size(6),
        .lsb_pos(9),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h20),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key_length.set_original_access("RW");
      // create field tags
      csr_excl.add_excl(key_length.get_full_name(), CsrExclWriteCheck, CsrNonInitTests);
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_cfg

  class hmac_reg_cmd extends dv_base_reg;
    // fields
    rand dv_base_reg_field hash_start;
    rand dv_base_reg_field hash_process;
    rand dv_base_reg_field hash_stop;
    rand dv_base_reg_field hash_continue;

    `uvm_object_utils(hmac_reg_cmd)

    function new(string       name = "hmac_reg_cmd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hash_start =
          (dv_base_reg_field::
           type_id::create("hash_start"));
      hash_start.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_start.set_original_access("W1C");
      hash_process =
          (dv_base_reg_field::
           type_id::create("hash_process"));
      hash_process.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_process.set_original_access("W1C");
      hash_stop =
          (dv_base_reg_field::
           type_id::create("hash_stop"));
      hash_stop.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_stop.set_original_access("W1C");
      hash_continue =
          (dv_base_reg_field::
           type_id::create("hash_continue"));
      hash_continue.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hash_continue.set_original_access("W1C");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_cmd

  class hmac_reg_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field hmac_idle;
    rand dv_base_reg_field fifo_empty;
    rand dv_base_reg_field fifo_full;
    rand dv_base_reg_field fifo_depth;

    `uvm_object_utils(hmac_reg_status)

    function new(string       name = "hmac_reg_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      hmac_idle =
          (dv_base_reg_field::
           type_id::create("hmac_idle"));
      hmac_idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hmac_idle.set_original_access("RO");
      fifo_empty =
          (dv_base_reg_field::
           type_id::create("fifo_empty"));
      fifo_empty.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_empty.set_original_access("RO");
      fifo_full =
          (dv_base_reg_field::
           type_id::create("fifo_full"));
      fifo_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_full.set_original_access("RO");
      fifo_depth =
          (dv_base_reg_field::
           type_id::create("fifo_depth"));
      fifo_depth.configure(
        .parent(this),
        .size(6),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_depth.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_status

  class hmac_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_code;

    `uvm_object_utils(hmac_reg_err_code)

    function new(string       name = "hmac_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      err_code =
          (dv_base_reg_field::
           type_id::create("err_code"));
      err_code.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_code.set_original_access("RO");
      // create field tags
      csr_excl.add_excl(err_code.get_full_name(), CsrExclCheck, CsrNonInitTests);
    endfunction : build
  endclass : hmac_reg_err_code

  class hmac_reg_wipe_secret extends dv_base_reg;
    // fields
    rand dv_base_reg_field secret;

    `uvm_object_utils(hmac_reg_wipe_secret)

    function new(string       name = "hmac_reg_wipe_secret",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      secret =
          (dv_base_reg_field::
           type_id::create("secret"));
      secret.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      secret.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_wipe_secret

  class hmac_reg_key extends dv_base_reg;
    // fields
    rand dv_base_reg_field key;

    `uvm_object_utils(hmac_reg_key)

    function new(string       name = "hmac_reg_key",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      key =
          (dv_base_reg_field::
           type_id::create("key_0"));
      key.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      key.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_key

  class hmac_reg_digest extends dv_base_reg;
    // fields
    rand dv_base_reg_field digest;

    `uvm_object_utils(hmac_reg_digest)

    function new(string       name = "hmac_reg_digest",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      digest =
          (dv_base_reg_field::
           type_id::create("digest_0"));
      digest.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      digest.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_digest

  class hmac_reg_msg_length_lower extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(hmac_reg_msg_length_lower)

    function new(string       name = "hmac_reg_msg_length_lower",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_msg_length_lower

  class hmac_reg_msg_length_upper extends dv_base_reg;
    // fields
    rand dv_base_reg_field v;

    `uvm_object_utils(hmac_reg_msg_length_upper)

    function new(string       name = "hmac_reg_msg_length_upper",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      v =
          (dv_base_reg_field::
           type_id::create("v"));
      v.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      v.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : hmac_reg_msg_length_upper

  class hmac_mem_msg_fifo extends dv_base_mem;

    `uvm_object_utils(hmac_mem_msg_fifo)

    function new(string           name = "hmac_mem_msg_fifo",
                 longint unsigned size = 1024,
                 int unsigned     n_bits = 32,
                 string           access = "WO",
                 int              has_coverage = UVM_NO_COVERAGE);
      super.new(name, size, n_bits, access, has_coverage);
      set_mem_partial_write_support(1);
    endfunction : new

  endclass : hmac_mem_msg_fifo


  class hmac_reg_block extends dv_base_reg_block;
    // registers
    rand hmac_reg_intr_state intr_state;
    rand hmac_reg_intr_enable intr_enable;
    rand hmac_reg_intr_test intr_test;
    rand hmac_reg_alert_test alert_test;
    rand hmac_reg_cfg cfg;
    rand hmac_reg_cmd cmd;
    rand hmac_reg_status status;
    rand hmac_reg_err_code err_code;
    rand hmac_reg_wipe_secret wipe_secret;
    rand hmac_reg_key key[32];
    rand hmac_reg_digest digest[16];
    rand hmac_reg_msg_length_lower msg_length_lower;
    rand hmac_reg_msg_length_upper msg_length_upper;
    // memories
    rand hmac_mem_msg_fifo msg_fifo;

    `uvm_object_utils(hmac_reg_block)

    function new(string name = "hmac_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (hmac_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_hmac_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_fifo_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_hmac_err.q",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (hmac_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_hmac_done.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_fifo_empty.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_hmac_err.q",
          2, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (hmac_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_hmac_done.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_fifo_empty.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_hmac_err.qs",
          2, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (hmac_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      cfg =
          (hmac_reg_cfg::
           type_id::create("cfg"));
      cfg.configure(.blk_parent(this));
      cfg.build(csr_excl);
      default_map.add_reg(.rg(cfg),
                          .offset(32'h10));
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_hmac_en.qs",
          0, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_sha_en.qs",
          1, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_endian_swap.qs",
          2, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_digest_swap.qs",
          3, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_key_swap.qs",
          4, 1, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_digest_size.qs",
          5, 4, 0, "BkdrRegPathRtl");
      cfg.add_hdl_path_slice(
          "u_reg.u_cfg_key_length.qs",
          9, 6, 0, "BkdrRegPathRtl");

      cmd =
          (hmac_reg_cmd::
           type_id::create("cmd"));
      cmd.configure(.blk_parent(this));
      cmd.build(csr_excl);
      default_map.add_reg(.rg(cmd),
                          .offset(32'h14));
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_hash_start.qs",
          0, 1, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_hash_process.qs",
          1, 1, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_hash_stop.qs",
          2, 1, 0, "BkdrRegPathRtl");
      cmd.add_hdl_path_slice(
          "u_reg.u_cmd_hash_continue.qs",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(cmd.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      status =
          (hmac_reg_status::
           type_id::create("status"));
      status.configure(.blk_parent(this));
      status.build(csr_excl);
      default_map.add_reg(.rg(status),
                          .offset(32'h18));
      status.add_hdl_path_slice(
          "u_reg.u_status_hmac_idle.qs",
          0, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_empty.qs",
          1, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_full.qs",
          2, 1, 0, "BkdrRegPathRtl");
      status.add_hdl_path_slice(
          "u_reg.u_status_fifo_depth.qs",
          4, 6, 0, "BkdrRegPathRtl");

      err_code =
          (hmac_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'h1c));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code.q",
          0, 32, 0, "BkdrRegPathRtl");

      wipe_secret =
          (hmac_reg_wipe_secret::
           type_id::create("wipe_secret"));
      wipe_secret.configure(.blk_parent(this));
      wipe_secret.build(csr_excl);
      default_map.add_reg(.rg(wipe_secret),
                          .offset(32'h20));
      wipe_secret.add_hdl_path_slice(
          "u_reg.u_wipe_secret.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wipe_secret.get_full_name(),
                        CsrExclWrite, CsrAllTests);
      key[0] =
          (hmac_reg_key::
           type_id::create("key_0"));
      key[0].configure(.blk_parent(this));
      key[0].build(csr_excl);
      default_map.add_reg(.rg(key[0]),
                          .offset(32'h24));
      key[0].add_hdl_path_slice(
          "u_reg.u_key_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[1] =
          (hmac_reg_key::
           type_id::create("key_1"));
      key[1].configure(.blk_parent(this));
      key[1].build(csr_excl);
      default_map.add_reg(.rg(key[1]),
                          .offset(32'h28));
      key[1].add_hdl_path_slice(
          "u_reg.u_key_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[2] =
          (hmac_reg_key::
           type_id::create("key_2"));
      key[2].configure(.blk_parent(this));
      key[2].build(csr_excl);
      default_map.add_reg(.rg(key[2]),
                          .offset(32'h2c));
      key[2].add_hdl_path_slice(
          "u_reg.u_key_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[3] =
          (hmac_reg_key::
           type_id::create("key_3"));
      key[3].configure(.blk_parent(this));
      key[3].build(csr_excl);
      default_map.add_reg(.rg(key[3]),
                          .offset(32'h30));
      key[3].add_hdl_path_slice(
          "u_reg.u_key_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[4] =
          (hmac_reg_key::
           type_id::create("key_4"));
      key[4].configure(.blk_parent(this));
      key[4].build(csr_excl);
      default_map.add_reg(.rg(key[4]),
                          .offset(32'h34));
      key[4].add_hdl_path_slice(
          "u_reg.u_key_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[5] =
          (hmac_reg_key::
           type_id::create("key_5"));
      key[5].configure(.blk_parent(this));
      key[5].build(csr_excl);
      default_map.add_reg(.rg(key[5]),
                          .offset(32'h38));
      key[5].add_hdl_path_slice(
          "u_reg.u_key_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[6] =
          (hmac_reg_key::
           type_id::create("key_6"));
      key[6].configure(.blk_parent(this));
      key[6].build(csr_excl);
      default_map.add_reg(.rg(key[6]),
                          .offset(32'h3c));
      key[6].add_hdl_path_slice(
          "u_reg.u_key_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[7] =
          (hmac_reg_key::
           type_id::create("key_7"));
      key[7].configure(.blk_parent(this));
      key[7].build(csr_excl);
      default_map.add_reg(.rg(key[7]),
                          .offset(32'h40));
      key[7].add_hdl_path_slice(
          "u_reg.u_key_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[8] =
          (hmac_reg_key::
           type_id::create("key_8"));
      key[8].configure(.blk_parent(this));
      key[8].build(csr_excl);
      default_map.add_reg(.rg(key[8]),
                          .offset(32'h44));
      key[8].add_hdl_path_slice(
          "u_reg.u_key_8.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[9] =
          (hmac_reg_key::
           type_id::create("key_9"));
      key[9].configure(.blk_parent(this));
      key[9].build(csr_excl);
      default_map.add_reg(.rg(key[9]),
                          .offset(32'h48));
      key[9].add_hdl_path_slice(
          "u_reg.u_key_9.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[10] =
          (hmac_reg_key::
           type_id::create("key_10"));
      key[10].configure(.blk_parent(this));
      key[10].build(csr_excl);
      default_map.add_reg(.rg(key[10]),
                          .offset(32'h4c));
      key[10].add_hdl_path_slice(
          "u_reg.u_key_10.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[11] =
          (hmac_reg_key::
           type_id::create("key_11"));
      key[11].configure(.blk_parent(this));
      key[11].build(csr_excl);
      default_map.add_reg(.rg(key[11]),
                          .offset(32'h50));
      key[11].add_hdl_path_slice(
          "u_reg.u_key_11.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[12] =
          (hmac_reg_key::
           type_id::create("key_12"));
      key[12].configure(.blk_parent(this));
      key[12].build(csr_excl);
      default_map.add_reg(.rg(key[12]),
                          .offset(32'h54));
      key[12].add_hdl_path_slice(
          "u_reg.u_key_12.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[13] =
          (hmac_reg_key::
           type_id::create("key_13"));
      key[13].configure(.blk_parent(this));
      key[13].build(csr_excl);
      default_map.add_reg(.rg(key[13]),
                          .offset(32'h58));
      key[13].add_hdl_path_slice(
          "u_reg.u_key_13.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[14] =
          (hmac_reg_key::
           type_id::create("key_14"));
      key[14].configure(.blk_parent(this));
      key[14].build(csr_excl);
      default_map.add_reg(.rg(key[14]),
                          .offset(32'h5c));
      key[14].add_hdl_path_slice(
          "u_reg.u_key_14.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[15] =
          (hmac_reg_key::
           type_id::create("key_15"));
      key[15].configure(.blk_parent(this));
      key[15].build(csr_excl);
      default_map.add_reg(.rg(key[15]),
                          .offset(32'h60));
      key[15].add_hdl_path_slice(
          "u_reg.u_key_15.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[16] =
          (hmac_reg_key::
           type_id::create("key_16"));
      key[16].configure(.blk_parent(this));
      key[16].build(csr_excl);
      default_map.add_reg(.rg(key[16]),
                          .offset(32'h64));
      key[16].add_hdl_path_slice(
          "u_reg.u_key_16.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[17] =
          (hmac_reg_key::
           type_id::create("key_17"));
      key[17].configure(.blk_parent(this));
      key[17].build(csr_excl);
      default_map.add_reg(.rg(key[17]),
                          .offset(32'h68));
      key[17].add_hdl_path_slice(
          "u_reg.u_key_17.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[18] =
          (hmac_reg_key::
           type_id::create("key_18"));
      key[18].configure(.blk_parent(this));
      key[18].build(csr_excl);
      default_map.add_reg(.rg(key[18]),
                          .offset(32'h6c));
      key[18].add_hdl_path_slice(
          "u_reg.u_key_18.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[19] =
          (hmac_reg_key::
           type_id::create("key_19"));
      key[19].configure(.blk_parent(this));
      key[19].build(csr_excl);
      default_map.add_reg(.rg(key[19]),
                          .offset(32'h70));
      key[19].add_hdl_path_slice(
          "u_reg.u_key_19.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[20] =
          (hmac_reg_key::
           type_id::create("key_20"));
      key[20].configure(.blk_parent(this));
      key[20].build(csr_excl);
      default_map.add_reg(.rg(key[20]),
                          .offset(32'h74));
      key[20].add_hdl_path_slice(
          "u_reg.u_key_20.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[21] =
          (hmac_reg_key::
           type_id::create("key_21"));
      key[21].configure(.blk_parent(this));
      key[21].build(csr_excl);
      default_map.add_reg(.rg(key[21]),
                          .offset(32'h78));
      key[21].add_hdl_path_slice(
          "u_reg.u_key_21.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[22] =
          (hmac_reg_key::
           type_id::create("key_22"));
      key[22].configure(.blk_parent(this));
      key[22].build(csr_excl);
      default_map.add_reg(.rg(key[22]),
                          .offset(32'h7c));
      key[22].add_hdl_path_slice(
          "u_reg.u_key_22.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[23] =
          (hmac_reg_key::
           type_id::create("key_23"));
      key[23].configure(.blk_parent(this));
      key[23].build(csr_excl);
      default_map.add_reg(.rg(key[23]),
                          .offset(32'h80));
      key[23].add_hdl_path_slice(
          "u_reg.u_key_23.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[24] =
          (hmac_reg_key::
           type_id::create("key_24"));
      key[24].configure(.blk_parent(this));
      key[24].build(csr_excl);
      default_map.add_reg(.rg(key[24]),
                          .offset(32'h84));
      key[24].add_hdl_path_slice(
          "u_reg.u_key_24.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[25] =
          (hmac_reg_key::
           type_id::create("key_25"));
      key[25].configure(.blk_parent(this));
      key[25].build(csr_excl);
      default_map.add_reg(.rg(key[25]),
                          .offset(32'h88));
      key[25].add_hdl_path_slice(
          "u_reg.u_key_25.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[26] =
          (hmac_reg_key::
           type_id::create("key_26"));
      key[26].configure(.blk_parent(this));
      key[26].build(csr_excl);
      default_map.add_reg(.rg(key[26]),
                          .offset(32'h8c));
      key[26].add_hdl_path_slice(
          "u_reg.u_key_26.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[27] =
          (hmac_reg_key::
           type_id::create("key_27"));
      key[27].configure(.blk_parent(this));
      key[27].build(csr_excl);
      default_map.add_reg(.rg(key[27]),
                          .offset(32'h90));
      key[27].add_hdl_path_slice(
          "u_reg.u_key_27.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[28] =
          (hmac_reg_key::
           type_id::create("key_28"));
      key[28].configure(.blk_parent(this));
      key[28].build(csr_excl);
      default_map.add_reg(.rg(key[28]),
                          .offset(32'h94));
      key[28].add_hdl_path_slice(
          "u_reg.u_key_28.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[29] =
          (hmac_reg_key::
           type_id::create("key_29"));
      key[29].configure(.blk_parent(this));
      key[29].build(csr_excl);
      default_map.add_reg(.rg(key[29]),
                          .offset(32'h98));
      key[29].add_hdl_path_slice(
          "u_reg.u_key_29.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[30] =
          (hmac_reg_key::
           type_id::create("key_30"));
      key[30].configure(.blk_parent(this));
      key[30].build(csr_excl);
      default_map.add_reg(.rg(key[30]),
                          .offset(32'h9c));
      key[30].add_hdl_path_slice(
          "u_reg.u_key_30.qs",
          0, 32, 0, "BkdrRegPathRtl");

      key[31] =
          (hmac_reg_key::
           type_id::create("key_31"));
      key[31].configure(.blk_parent(this));
      key[31].build(csr_excl);
      default_map.add_reg(.rg(key[31]),
                          .offset(32'ha0));
      key[31].add_hdl_path_slice(
          "u_reg.u_key_31.qs",
          0, 32, 0, "BkdrRegPathRtl");

      digest[0] =
          (hmac_reg_digest::
           type_id::create("digest_0"));
      digest[0].configure(.blk_parent(this));
      digest[0].build(csr_excl);
      default_map.add_reg(.rg(digest[0]),
                          .offset(32'ha4));
      digest[0].add_hdl_path_slice(
          "u_reg.u_digest_0.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[0].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[1] =
          (hmac_reg_digest::
           type_id::create("digest_1"));
      digest[1].configure(.blk_parent(this));
      digest[1].build(csr_excl);
      default_map.add_reg(.rg(digest[1]),
                          .offset(32'ha8));
      digest[1].add_hdl_path_slice(
          "u_reg.u_digest_1.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[1].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[2] =
          (hmac_reg_digest::
           type_id::create("digest_2"));
      digest[2].configure(.blk_parent(this));
      digest[2].build(csr_excl);
      default_map.add_reg(.rg(digest[2]),
                          .offset(32'hac));
      digest[2].add_hdl_path_slice(
          "u_reg.u_digest_2.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[2].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[3] =
          (hmac_reg_digest::
           type_id::create("digest_3"));
      digest[3].configure(.blk_parent(this));
      digest[3].build(csr_excl);
      default_map.add_reg(.rg(digest[3]),
                          .offset(32'hb0));
      digest[3].add_hdl_path_slice(
          "u_reg.u_digest_3.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[3].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[4] =
          (hmac_reg_digest::
           type_id::create("digest_4"));
      digest[4].configure(.blk_parent(this));
      digest[4].build(csr_excl);
      default_map.add_reg(.rg(digest[4]),
                          .offset(32'hb4));
      digest[4].add_hdl_path_slice(
          "u_reg.u_digest_4.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[4].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[5] =
          (hmac_reg_digest::
           type_id::create("digest_5"));
      digest[5].configure(.blk_parent(this));
      digest[5].build(csr_excl);
      default_map.add_reg(.rg(digest[5]),
                          .offset(32'hb8));
      digest[5].add_hdl_path_slice(
          "u_reg.u_digest_5.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[5].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[6] =
          (hmac_reg_digest::
           type_id::create("digest_6"));
      digest[6].configure(.blk_parent(this));
      digest[6].build(csr_excl);
      default_map.add_reg(.rg(digest[6]),
                          .offset(32'hbc));
      digest[6].add_hdl_path_slice(
          "u_reg.u_digest_6.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[6].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[7] =
          (hmac_reg_digest::
           type_id::create("digest_7"));
      digest[7].configure(.blk_parent(this));
      digest[7].build(csr_excl);
      default_map.add_reg(.rg(digest[7]),
                          .offset(32'hc0));
      digest[7].add_hdl_path_slice(
          "u_reg.u_digest_7.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[7].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[8] =
          (hmac_reg_digest::
           type_id::create("digest_8"));
      digest[8].configure(.blk_parent(this));
      digest[8].build(csr_excl);
      default_map.add_reg(.rg(digest[8]),
                          .offset(32'hc4));
      digest[8].add_hdl_path_slice(
          "u_reg.u_digest_8.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[8].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[9] =
          (hmac_reg_digest::
           type_id::create("digest_9"));
      digest[9].configure(.blk_parent(this));
      digest[9].build(csr_excl);
      default_map.add_reg(.rg(digest[9]),
                          .offset(32'hc8));
      digest[9].add_hdl_path_slice(
          "u_reg.u_digest_9.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[9].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[10] =
          (hmac_reg_digest::
           type_id::create("digest_10"));
      digest[10].configure(.blk_parent(this));
      digest[10].build(csr_excl);
      default_map.add_reg(.rg(digest[10]),
                          .offset(32'hcc));
      digest[10].add_hdl_path_slice(
          "u_reg.u_digest_10.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[10].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[11] =
          (hmac_reg_digest::
           type_id::create("digest_11"));
      digest[11].configure(.blk_parent(this));
      digest[11].build(csr_excl);
      default_map.add_reg(.rg(digest[11]),
                          .offset(32'hd0));
      digest[11].add_hdl_path_slice(
          "u_reg.u_digest_11.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[11].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[12] =
          (hmac_reg_digest::
           type_id::create("digest_12"));
      digest[12].configure(.blk_parent(this));
      digest[12].build(csr_excl);
      default_map.add_reg(.rg(digest[12]),
                          .offset(32'hd4));
      digest[12].add_hdl_path_slice(
          "u_reg.u_digest_12.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[12].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[13] =
          (hmac_reg_digest::
           type_id::create("digest_13"));
      digest[13].configure(.blk_parent(this));
      digest[13].build(csr_excl);
      default_map.add_reg(.rg(digest[13]),
                          .offset(32'hd8));
      digest[13].add_hdl_path_slice(
          "u_reg.u_digest_13.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[13].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[14] =
          (hmac_reg_digest::
           type_id::create("digest_14"));
      digest[14].configure(.blk_parent(this));
      digest[14].build(csr_excl);
      default_map.add_reg(.rg(digest[14]),
                          .offset(32'hdc));
      digest[14].add_hdl_path_slice(
          "u_reg.u_digest_14.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[14].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      digest[15] =
          (hmac_reg_digest::
           type_id::create("digest_15"));
      digest[15].configure(.blk_parent(this));
      digest[15].build(csr_excl);
      default_map.add_reg(.rg(digest[15]),
                          .offset(32'he0));
      digest[15].add_hdl_path_slice(
          "u_reg.u_digest_15.qs",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(digest[15].get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      msg_length_lower =
          (hmac_reg_msg_length_lower::
           type_id::create("msg_length_lower"));
      msg_length_lower.configure(.blk_parent(this));
      msg_length_lower.build(csr_excl);
      default_map.add_reg(.rg(msg_length_lower),
                          .offset(32'he4));
      msg_length_lower.add_hdl_path_slice(
          "u_reg.u_msg_length_lower.qs",
          0, 32, 0, "BkdrRegPathRtl");

      msg_length_upper =
          (hmac_reg_msg_length_upper::
           type_id::create("msg_length_upper"));
      msg_length_upper.configure(.blk_parent(this));
      msg_length_upper.build(csr_excl);
      default_map.add_reg(.rg(msg_length_upper),
                          .offset(32'he8));
      msg_length_upper.add_hdl_path_slice(
          "u_reg.u_msg_length_upper.qs",
          0, 32, 0, "BkdrRegPathRtl");


      // create memories
      msg_fifo =
          hmac_mem_msg_fifo::type_id::create("msg_fifo");
      msg_fifo.configure(.parent(this));
      default_map.add_mem(.mem(msg_fifo),
                          .offset(32'h1000),
                          .rights("WO"));


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : hmac_reg_block

endpackage

