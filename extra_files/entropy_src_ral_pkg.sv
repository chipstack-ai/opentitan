// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package entropy_src_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class entropy_src_reg_intr_state;
  typedef class entropy_src_reg_intr_enable;
  typedef class entropy_src_reg_intr_test;
  typedef class entropy_src_reg_alert_test;
  typedef class entropy_src_reg_me_regwen;
  typedef class entropy_src_reg_sw_regupd;
  typedef class entropy_src_reg_regwen;
  typedef class entropy_src_reg_rev;
  typedef class entropy_src_reg_module_enable;
  typedef class entropy_src_reg_conf;
  typedef class entropy_src_reg_entropy_control;
  typedef class entropy_src_reg_entropy_data;
  typedef class entropy_src_reg_health_test_windows;
  typedef class entropy_src_reg_repcnt_thresholds;
  typedef class entropy_src_reg_repcnts_thresholds;
  typedef class entropy_src_reg_adaptp_hi_thresholds;
  typedef class entropy_src_reg_adaptp_lo_thresholds;
  typedef class entropy_src_reg_bucket_thresholds;
  typedef class entropy_src_reg_markov_hi_thresholds;
  typedef class entropy_src_reg_markov_lo_thresholds;
  typedef class entropy_src_reg_extht_hi_thresholds;
  typedef class entropy_src_reg_extht_lo_thresholds;
  typedef class entropy_src_reg_repcnt_hi_watermarks;
  typedef class entropy_src_reg_repcnts_hi_watermarks;
  typedef class entropy_src_reg_adaptp_hi_watermarks;
  typedef class entropy_src_reg_adaptp_lo_watermarks;
  typedef class entropy_src_reg_extht_hi_watermarks;
  typedef class entropy_src_reg_extht_lo_watermarks;
  typedef class entropy_src_reg_bucket_hi_watermarks;
  typedef class entropy_src_reg_markov_hi_watermarks;
  typedef class entropy_src_reg_markov_lo_watermarks;
  typedef class entropy_src_reg_repcnt_total_fails;
  typedef class entropy_src_reg_repcnts_total_fails;
  typedef class entropy_src_reg_adaptp_hi_total_fails;
  typedef class entropy_src_reg_adaptp_lo_total_fails;
  typedef class entropy_src_reg_bucket_total_fails;
  typedef class entropy_src_reg_markov_hi_total_fails;
  typedef class entropy_src_reg_markov_lo_total_fails;
  typedef class entropy_src_reg_extht_hi_total_fails;
  typedef class entropy_src_reg_extht_lo_total_fails;
  typedef class entropy_src_reg_alert_threshold;
  typedef class entropy_src_reg_alert_summary_fail_counts;
  typedef class entropy_src_reg_alert_fail_counts;
  typedef class entropy_src_reg_extht_fail_counts;
  typedef class entropy_src_reg_fw_ov_control;
  typedef class entropy_src_reg_fw_ov_sha3_start;
  typedef class entropy_src_reg_fw_ov_wr_fifo_full;
  typedef class entropy_src_reg_fw_ov_rd_fifo_overflow;
  typedef class entropy_src_reg_fw_ov_rd_data;
  typedef class entropy_src_reg_fw_ov_wr_data;
  typedef class entropy_src_reg_observe_fifo_thresh;
  typedef class entropy_src_reg_observe_fifo_depth;
  typedef class entropy_src_reg_debug_status;
  typedef class entropy_src_reg_recov_alert_sts;
  typedef class entropy_src_reg_err_code;
  typedef class entropy_src_reg_err_code_test;
  typedef class entropy_src_reg_main_sm_state;
  typedef class entropy_src_reg_block;

  class entropy_src_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field es_entropy_valid;
    rand dv_base_reg_field es_health_test_failed;
    rand dv_base_reg_field es_observe_fifo_ready;
    rand dv_base_reg_field es_fatal_err;

    `uvm_object_utils(entropy_src_reg_intr_state)

    function new(string       name = "entropy_src_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      es_entropy_valid =
          (dv_base_reg_field::
           type_id::create("es_entropy_valid"));
      es_entropy_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_entropy_valid.set_original_access("W1C");
      es_health_test_failed =
          (dv_base_reg_field::
           type_id::create("es_health_test_failed"));
      es_health_test_failed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_health_test_failed.set_original_access("W1C");
      es_observe_fifo_ready =
          (dv_base_reg_field::
           type_id::create("es_observe_fifo_ready"));
      es_observe_fifo_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_observe_fifo_ready.set_original_access("W1C");
      es_fatal_err =
          (dv_base_reg_field::
           type_id::create("es_fatal_err"));
      es_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_fatal_err.set_original_access("W1C");
    endfunction : build
  endclass : entropy_src_reg_intr_state

  class entropy_src_reg_intr_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field es_entropy_valid;
    rand dv_base_reg_field es_health_test_failed;
    rand dv_base_reg_field es_observe_fifo_ready;
    rand dv_base_reg_field es_fatal_err;

    `uvm_object_utils(entropy_src_reg_intr_enable)

    function new(string       name = "entropy_src_reg_intr_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      es_entropy_valid =
          (dv_base_reg_field::
           type_id::create("es_entropy_valid"));
      es_entropy_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_entropy_valid.set_original_access("RW");
      es_health_test_failed =
          (dv_base_reg_field::
           type_id::create("es_health_test_failed"));
      es_health_test_failed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_health_test_failed.set_original_access("RW");
      es_observe_fifo_ready =
          (dv_base_reg_field::
           type_id::create("es_observe_fifo_ready"));
      es_observe_fifo_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_observe_fifo_ready.set_original_access("RW");
      es_fatal_err =
          (dv_base_reg_field::
           type_id::create("es_fatal_err"));
      es_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_fatal_err.set_original_access("RW");
    endfunction : build
  endclass : entropy_src_reg_intr_enable

  class entropy_src_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field es_entropy_valid;
    rand dv_base_reg_field es_health_test_failed;
    rand dv_base_reg_field es_observe_fifo_ready;
    rand dv_base_reg_field es_fatal_err;

    `uvm_object_utils(entropy_src_reg_intr_test)

    function new(string       name = "entropy_src_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      es_entropy_valid =
          (dv_base_reg_field::
           type_id::create("es_entropy_valid"));
      es_entropy_valid.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_entropy_valid.set_original_access("WO");
      es_health_test_failed =
          (dv_base_reg_field::
           type_id::create("es_health_test_failed"));
      es_health_test_failed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_health_test_failed.set_original_access("WO");
      es_observe_fifo_ready =
          (dv_base_reg_field::
           type_id::create("es_observe_fifo_ready"));
      es_observe_fifo_ready.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_observe_fifo_ready.set_original_access("WO");
      es_fatal_err =
          (dv_base_reg_field::
           type_id::create("es_fatal_err"));
      es_fatal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_fatal_err.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_intr_test

  class entropy_src_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field recov_alert;
    rand dv_base_reg_field fatal_alert;

    `uvm_object_utils(entropy_src_reg_alert_test)

    function new(string       name = "entropy_src_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      recov_alert =
          (dv_base_reg_field::
           type_id::create("recov_alert"));
      recov_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      recov_alert.set_original_access("WO");
      fatal_alert =
          (dv_base_reg_field::
           type_id::create("fatal_alert"));
      fatal_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_alert.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_alert_test

  class entropy_src_reg_me_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field me_regwen;

    `uvm_object_utils(entropy_src_reg_me_regwen)

    function new(string       name = "entropy_src_reg_me_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      me_regwen =
          (dv_base_reg_field::
           type_id::create("me_regwen"));
      me_regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      me_regwen.set_original_access("W0C");
    endfunction : build
  endclass : entropy_src_reg_me_regwen

  class entropy_src_reg_sw_regupd extends dv_base_reg;
    // fields
    rand dv_base_reg_field sw_regupd;

    `uvm_object_utils(entropy_src_reg_sw_regupd)

    function new(string       name = "entropy_src_reg_sw_regupd",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sw_regupd =
          (dv_base_reg_field::
           type_id::create("sw_regupd"));
      sw_regupd.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sw_regupd.set_original_access("W0C");
    endfunction : build
  endclass : entropy_src_reg_sw_regupd

  class entropy_src_reg_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(entropy_src_reg_regwen)

    function new(string       name = "entropy_src_reg_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("RO");
    endfunction : build
  endclass : entropy_src_reg_regwen

  class entropy_src_reg_rev extends dv_base_reg;
    // fields
    rand dv_base_reg_field abi_revision;
    rand dv_base_reg_field hw_revision;
    rand dv_base_reg_field chip_type;

    `uvm_object_utils(entropy_src_reg_rev)

    function new(string       name = "entropy_src_reg_rev",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      abi_revision =
          (dv_base_reg_field::
           type_id::create("abi_revision"));
      abi_revision.configure(
        .parent(this),
        .size(8),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h3),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      abi_revision.set_original_access("RO");
      hw_revision =
          (dv_base_reg_field::
           type_id::create("hw_revision"));
      hw_revision.configure(
        .parent(this),
        .size(8),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h3),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      hw_revision.set_original_access("RO");
      chip_type =
          (dv_base_reg_field::
           type_id::create("chip_type"));
      chip_type.configure(
        .parent(this),
        .size(8),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      chip_type.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_rev

  class entropy_src_reg_module_enable extends dv_base_reg;
    // fields
    rand dv_base_reg_field module_enable;

    `uvm_object_utils(entropy_src_reg_module_enable)

    function new(string       name = "entropy_src_reg_module_enable",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      module_enable =
          (dv_base_reg_field::
           type_id::create("module_enable"));
      module_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      module_enable.set_original_access("RW");
      module_enable.set_mubi_width(4);
    endfunction : build
  endclass : entropy_src_reg_module_enable

  class entropy_src_reg_conf extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_enable;
    rand dv_base_reg_field fips_flag;
    rand dv_base_reg_field rng_fips;
    rand dv_base_reg_field rng_bit_enable;
    rand dv_base_reg_field rng_bit_sel;
    rand dv_base_reg_field threshold_scope;
    rand dv_base_reg_field entropy_data_reg_enable;

    `uvm_object_utils(entropy_src_reg_conf)

    function new(string       name = "entropy_src_reg_conf",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_enable =
          (dv_base_reg_field::
           type_id::create("fips_enable"));
      fips_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_enable.set_original_access("RW");
      fips_enable.set_mubi_width(4);
      fips_flag =
          (dv_base_reg_field::
           type_id::create("fips_flag"));
      fips_flag.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_flag.set_original_access("RW");
      fips_flag.set_mubi_width(4);
      rng_fips =
          (dv_base_reg_field::
           type_id::create("rng_fips"));
      rng_fips.configure(
        .parent(this),
        .size(4),
        .lsb_pos(8),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rng_fips.set_original_access("RW");
      rng_fips.set_mubi_width(4);
      rng_bit_enable =
          (dv_base_reg_field::
           type_id::create("rng_bit_enable"));
      rng_bit_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(12),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rng_bit_enable.set_original_access("RW");
      rng_bit_enable.set_mubi_width(4);
      rng_bit_sel =
          (dv_base_reg_field::
           type_id::create("rng_bit_sel"));
      rng_bit_sel.configure(
        .parent(this),
        .size(2),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rng_bit_sel.set_original_access("RW");
      threshold_scope =
          (dv_base_reg_field::
           type_id::create("threshold_scope"));
      threshold_scope.configure(
        .parent(this),
        .size(4),
        .lsb_pos(18),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold_scope.set_original_access("RW");
      threshold_scope.set_mubi_width(4);
      entropy_data_reg_enable =
          (dv_base_reg_field::
           type_id::create("entropy_data_reg_enable"));
      entropy_data_reg_enable.configure(
        .parent(this),
        .size(4),
        .lsb_pos(22),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_data_reg_enable.set_original_access("RW");
      entropy_data_reg_enable.set_mubi_width(4);
    endfunction : build
  endclass : entropy_src_reg_conf

  class entropy_src_reg_entropy_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field es_route;
    rand dv_base_reg_field es_type;

    `uvm_object_utils(entropy_src_reg_entropy_control)

    function new(string       name = "entropy_src_reg_entropy_control",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      es_route =
          (dv_base_reg_field::
           type_id::create("es_route"));
      es_route.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_route.set_original_access("RW");
      es_route.set_mubi_width(4);
      es_type =
          (dv_base_reg_field::
           type_id::create("es_type"));
      es_type.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_type.set_original_access("RW");
      es_type.set_mubi_width(4);
    endfunction : build
  endclass : entropy_src_reg_entropy_control

  class entropy_src_reg_entropy_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field entropy_data;

    `uvm_object_utils(entropy_src_reg_entropy_data)

    function new(string       name = "entropy_src_reg_entropy_data",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      entropy_data =
          (dv_base_reg_field::
           type_id::create("entropy_data"));
      entropy_data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_data.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_entropy_data

  class entropy_src_reg_health_test_windows extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_window;
    rand dv_base_reg_field bypass_window;

    `uvm_object_utils(entropy_src_reg_health_test_windows)

    function new(string       name = "entropy_src_reg_health_test_windows",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_window =
          (dv_base_reg_field::
           type_id::create("fips_window"));
      fips_window.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h200),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_window.set_original_access("RW");
      bypass_window =
          (dv_base_reg_field::
           type_id::create("bypass_window"));
      bypass_window.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h60),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_window.set_original_access("RW");
    endfunction : build
  endclass : entropy_src_reg_health_test_windows

  class entropy_src_reg_repcnt_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_repcnt_thresholds)

    function new(string       name = "entropy_src_reg_repcnt_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnt_thresholds

  class entropy_src_reg_repcnts_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_repcnts_thresholds)

    function new(string       name = "entropy_src_reg_repcnts_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnts_thresholds

  class entropy_src_reg_adaptp_hi_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_adaptp_hi_thresholds)

    function new(string       name = "entropy_src_reg_adaptp_hi_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_hi_thresholds

  class entropy_src_reg_adaptp_lo_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_adaptp_lo_thresholds)

    function new(string       name = "entropy_src_reg_adaptp_lo_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_lo_thresholds

  class entropy_src_reg_bucket_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_bucket_thresholds)

    function new(string       name = "entropy_src_reg_bucket_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_bucket_thresholds

  class entropy_src_reg_markov_hi_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_markov_hi_thresholds)

    function new(string       name = "entropy_src_reg_markov_hi_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_hi_thresholds

  class entropy_src_reg_markov_lo_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_markov_lo_thresholds)

    function new(string       name = "entropy_src_reg_markov_lo_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_lo_thresholds

  class entropy_src_reg_extht_hi_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_extht_hi_thresholds)

    function new(string       name = "entropy_src_reg_extht_hi_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_hi_thresholds

  class entropy_src_reg_extht_lo_thresholds extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_thresh;
    rand dv_base_reg_field bypass_thresh;

    `uvm_object_utils(entropy_src_reg_extht_lo_thresholds)

    function new(string       name = "entropy_src_reg_extht_lo_thresholds",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_thresh =
          (dv_base_reg_field::
           type_id::create("fips_thresh"));
      fips_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_thresh.set_original_access("RW");
      bypass_thresh =
          (dv_base_reg_field::
           type_id::create("bypass_thresh"));
      bypass_thresh.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_thresh.set_original_access("RW");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_lo_thresholds

  class entropy_src_reg_repcnt_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_repcnt_hi_watermarks)

    function new(string       name = "entropy_src_reg_repcnt_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnt_hi_watermarks

  class entropy_src_reg_repcnts_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_repcnts_hi_watermarks)

    function new(string       name = "entropy_src_reg_repcnts_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnts_hi_watermarks

  class entropy_src_reg_adaptp_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_adaptp_hi_watermarks)

    function new(string       name = "entropy_src_reg_adaptp_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_hi_watermarks

  class entropy_src_reg_adaptp_lo_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_adaptp_lo_watermarks)

    function new(string       name = "entropy_src_reg_adaptp_lo_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_lo_watermarks

  class entropy_src_reg_extht_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_extht_hi_watermarks)

    function new(string       name = "entropy_src_reg_extht_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_hi_watermarks

  class entropy_src_reg_extht_lo_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_extht_lo_watermarks)

    function new(string       name = "entropy_src_reg_extht_lo_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_lo_watermarks

  class entropy_src_reg_bucket_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_bucket_hi_watermarks)

    function new(string       name = "entropy_src_reg_bucket_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_bucket_hi_watermarks

  class entropy_src_reg_markov_hi_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_markov_hi_watermarks)

    function new(string       name = "entropy_src_reg_markov_hi_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_hi_watermarks

  class entropy_src_reg_markov_lo_watermarks extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_watermark;
    rand dv_base_reg_field bypass_watermark;

    `uvm_object_utils(entropy_src_reg_markov_lo_watermarks)

    function new(string       name = "entropy_src_reg_markov_lo_watermarks",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_watermark =
          (dv_base_reg_field::
           type_id::create("fips_watermark"));
      fips_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_watermark.set_original_access("RO");
      bypass_watermark =
          (dv_base_reg_field::
           type_id::create("bypass_watermark"));
      bypass_watermark.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hffff),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bypass_watermark.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_lo_watermarks

  class entropy_src_reg_repcnt_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field repcnt_total_fails;

    `uvm_object_utils(entropy_src_reg_repcnt_total_fails)

    function new(string       name = "entropy_src_reg_repcnt_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      repcnt_total_fails =
          (dv_base_reg_field::
           type_id::create("repcnt_total_fails"));
      repcnt_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      repcnt_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnt_total_fails

  class entropy_src_reg_repcnts_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field repcnts_total_fails;

    `uvm_object_utils(entropy_src_reg_repcnts_total_fails)

    function new(string       name = "entropy_src_reg_repcnts_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      repcnts_total_fails =
          (dv_base_reg_field::
           type_id::create("repcnts_total_fails"));
      repcnts_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      repcnts_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_repcnts_total_fails

  class entropy_src_reg_adaptp_hi_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field adaptp_hi_total_fails;

    `uvm_object_utils(entropy_src_reg_adaptp_hi_total_fails)

    function new(string       name = "entropy_src_reg_adaptp_hi_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      adaptp_hi_total_fails =
          (dv_base_reg_field::
           type_id::create("adaptp_hi_total_fails"));
      adaptp_hi_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adaptp_hi_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_hi_total_fails

  class entropy_src_reg_adaptp_lo_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field adaptp_lo_total_fails;

    `uvm_object_utils(entropy_src_reg_adaptp_lo_total_fails)

    function new(string       name = "entropy_src_reg_adaptp_lo_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      adaptp_lo_total_fails =
          (dv_base_reg_field::
           type_id::create("adaptp_lo_total_fails"));
      adaptp_lo_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adaptp_lo_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_adaptp_lo_total_fails

  class entropy_src_reg_bucket_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field bucket_total_fails;

    `uvm_object_utils(entropy_src_reg_bucket_total_fails)

    function new(string       name = "entropy_src_reg_bucket_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      bucket_total_fails =
          (dv_base_reg_field::
           type_id::create("bucket_total_fails"));
      bucket_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bucket_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_bucket_total_fails

  class entropy_src_reg_markov_hi_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field markov_hi_total_fails;

    `uvm_object_utils(entropy_src_reg_markov_hi_total_fails)

    function new(string       name = "entropy_src_reg_markov_hi_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      markov_hi_total_fails =
          (dv_base_reg_field::
           type_id::create("markov_hi_total_fails"));
      markov_hi_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      markov_hi_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_hi_total_fails

  class entropy_src_reg_markov_lo_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field markov_lo_total_fails;

    `uvm_object_utils(entropy_src_reg_markov_lo_total_fails)

    function new(string       name = "entropy_src_reg_markov_lo_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      markov_lo_total_fails =
          (dv_base_reg_field::
           type_id::create("markov_lo_total_fails"));
      markov_lo_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      markov_lo_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_markov_lo_total_fails

  class entropy_src_reg_extht_hi_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field extht_hi_total_fails;

    `uvm_object_utils(entropy_src_reg_extht_hi_total_fails)

    function new(string       name = "entropy_src_reg_extht_hi_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      extht_hi_total_fails =
          (dv_base_reg_field::
           type_id::create("extht_hi_total_fails"));
      extht_hi_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      extht_hi_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_hi_total_fails

  class entropy_src_reg_extht_lo_total_fails extends dv_base_reg;
    // fields
    rand dv_base_reg_field extht_lo_total_fails;

    `uvm_object_utils(entropy_src_reg_extht_lo_total_fails)

    function new(string       name = "entropy_src_reg_extht_lo_total_fails",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      extht_lo_total_fails =
          (dv_base_reg_field::
           type_id::create("extht_lo_total_fails"));
      extht_lo_total_fails.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      extht_lo_total_fails.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_lo_total_fails

  class entropy_src_reg_alert_threshold extends dv_base_reg;
    // fields
    rand dv_base_reg_field alert_threshold;
    rand dv_base_reg_field alert_threshold_inv;

    `uvm_object_utils(entropy_src_reg_alert_threshold)

    function new(string       name = "entropy_src_reg_alert_threshold",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      alert_threshold =
          (dv_base_reg_field::
           type_id::create("alert_threshold"));
      alert_threshold.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h2),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_threshold.set_original_access("RW");
      alert_threshold_inv =
          (dv_base_reg_field::
           type_id::create("alert_threshold_inv"));
      alert_threshold_inv.configure(
        .parent(this),
        .size(16),
        .lsb_pos(16),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'hfffd),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      alert_threshold_inv.set_original_access("RW");
    endfunction : build
  endclass : entropy_src_reg_alert_threshold

  class entropy_src_reg_alert_summary_fail_counts extends dv_base_reg;
    // fields
    rand dv_base_reg_field any_fail_count;

    `uvm_object_utils(entropy_src_reg_alert_summary_fail_counts)

    function new(string       name = "entropy_src_reg_alert_summary_fail_counts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      any_fail_count =
          (dv_base_reg_field::
           type_id::create("any_fail_count"));
      any_fail_count.configure(
        .parent(this),
        .size(16),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      any_fail_count.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_alert_summary_fail_counts

  class entropy_src_reg_alert_fail_counts extends dv_base_reg;
    // fields
    rand dv_base_reg_field repcnt_fail_count;
    rand dv_base_reg_field adaptp_hi_fail_count;
    rand dv_base_reg_field adaptp_lo_fail_count;
    rand dv_base_reg_field bucket_fail_count;
    rand dv_base_reg_field markov_hi_fail_count;
    rand dv_base_reg_field markov_lo_fail_count;
    rand dv_base_reg_field repcnts_fail_count;

    `uvm_object_utils(entropy_src_reg_alert_fail_counts)

    function new(string       name = "entropy_src_reg_alert_fail_counts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      repcnt_fail_count =
          (dv_base_reg_field::
           type_id::create("repcnt_fail_count"));
      repcnt_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      repcnt_fail_count.set_original_access("RO");
      adaptp_hi_fail_count =
          (dv_base_reg_field::
           type_id::create("adaptp_hi_fail_count"));
      adaptp_hi_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adaptp_hi_fail_count.set_original_access("RO");
      adaptp_lo_fail_count =
          (dv_base_reg_field::
           type_id::create("adaptp_lo_fail_count"));
      adaptp_lo_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(12),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      adaptp_lo_fail_count.set_original_access("RO");
      bucket_fail_count =
          (dv_base_reg_field::
           type_id::create("bucket_fail_count"));
      bucket_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      bucket_fail_count.set_original_access("RO");
      markov_hi_fail_count =
          (dv_base_reg_field::
           type_id::create("markov_hi_fail_count"));
      markov_hi_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      markov_hi_fail_count.set_original_access("RO");
      markov_lo_fail_count =
          (dv_base_reg_field::
           type_id::create("markov_lo_fail_count"));
      markov_lo_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      markov_lo_fail_count.set_original_access("RO");
      repcnts_fail_count =
          (dv_base_reg_field::
           type_id::create("repcnts_fail_count"));
      repcnts_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(28),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      repcnts_fail_count.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_alert_fail_counts

  class entropy_src_reg_extht_fail_counts extends dv_base_reg;
    // fields
    rand dv_base_reg_field extht_hi_fail_count;
    rand dv_base_reg_field extht_lo_fail_count;

    `uvm_object_utils(entropy_src_reg_extht_fail_counts)

    function new(string       name = "entropy_src_reg_extht_fail_counts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      extht_hi_fail_count =
          (dv_base_reg_field::
           type_id::create("extht_hi_fail_count"));
      extht_hi_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      extht_hi_fail_count.set_original_access("RO");
      extht_lo_fail_count =
          (dv_base_reg_field::
           type_id::create("extht_lo_fail_count"));
      extht_lo_fail_count.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      extht_lo_fail_count.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_extht_fail_counts

  class entropy_src_reg_fw_ov_control extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_mode;
    rand dv_base_reg_field fw_ov_entropy_insert;

    `uvm_object_utils(entropy_src_reg_fw_ov_control)

    function new(string       name = "entropy_src_reg_fw_ov_control",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_mode =
          (dv_base_reg_field::
           type_id::create("fw_ov_mode"));
      fw_ov_mode.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_mode.set_original_access("RW");
      fw_ov_mode.set_mubi_width(4);
      fw_ov_entropy_insert =
          (dv_base_reg_field::
           type_id::create("fw_ov_entropy_insert"));
      fw_ov_entropy_insert.configure(
        .parent(this),
        .size(4),
        .lsb_pos(4),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_entropy_insert.set_original_access("RW");
      fw_ov_entropy_insert.set_mubi_width(4);
    endfunction : build
  endclass : entropy_src_reg_fw_ov_control

  class entropy_src_reg_fw_ov_sha3_start extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_insert_start;

    `uvm_object_utils(entropy_src_reg_fw_ov_sha3_start)

    function new(string       name = "entropy_src_reg_fw_ov_sha3_start",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_insert_start =
          (dv_base_reg_field::
           type_id::create("fw_ov_insert_start"));
      fw_ov_insert_start.configure(
        .parent(this),
        .size(4),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("RW"),
        .volatile(0),
        .reset(32'h9),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_insert_start.set_original_access("RW");
      fw_ov_insert_start.set_mubi_width(4);
    endfunction : build
  endclass : entropy_src_reg_fw_ov_sha3_start

  class entropy_src_reg_fw_ov_wr_fifo_full extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_wr_fifo_full;

    `uvm_object_utils(entropy_src_reg_fw_ov_wr_fifo_full)

    function new(string       name = "entropy_src_reg_fw_ov_wr_fifo_full",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_wr_fifo_full =
          (dv_base_reg_field::
           type_id::create("fw_ov_wr_fifo_full"));
      fw_ov_wr_fifo_full.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_wr_fifo_full.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_fw_ov_wr_fifo_full

  class entropy_src_reg_fw_ov_rd_fifo_overflow extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_rd_fifo_overflow;

    `uvm_object_utils(entropy_src_reg_fw_ov_rd_fifo_overflow)

    function new(string       name = "entropy_src_reg_fw_ov_rd_fifo_overflow",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_rd_fifo_overflow =
          (dv_base_reg_field::
           type_id::create("fw_ov_rd_fifo_overflow"));
      fw_ov_rd_fifo_overflow.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_rd_fifo_overflow.set_original_access("RO");
    endfunction : build
  endclass : entropy_src_reg_fw_ov_rd_fifo_overflow

  class entropy_src_reg_fw_ov_rd_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_rd_data;

    `uvm_object_utils(entropy_src_reg_fw_ov_rd_data)

    function new(string       name = "entropy_src_reg_fw_ov_rd_data",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_rd_data =
          (dv_base_reg_field::
           type_id::create("fw_ov_rd_data"));
      fw_ov_rd_data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_rd_data.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_fw_ov_rd_data

  class entropy_src_reg_fw_ov_wr_data extends dv_base_reg;
    // fields
    rand dv_base_reg_field fw_ov_wr_data;

    `uvm_object_utils(entropy_src_reg_fw_ov_wr_data)

    function new(string       name = "entropy_src_reg_fw_ov_wr_data",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fw_ov_wr_data =
          (dv_base_reg_field::
           type_id::create("fw_ov_wr_data"));
      fw_ov_wr_data.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_wr_data.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_fw_ov_wr_data

  class entropy_src_reg_observe_fifo_thresh extends dv_base_reg;
    // fields
    rand dv_base_reg_field observe_fifo_thresh;

    `uvm_object_utils(entropy_src_reg_observe_fifo_thresh)

    function new(string       name = "entropy_src_reg_observe_fifo_thresh",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      observe_fifo_thresh =
          (dv_base_reg_field::
           type_id::create("observe_fifo_thresh"));
      observe_fifo_thresh.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h10),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      observe_fifo_thresh.set_original_access("RW");
    endfunction : build
  endclass : entropy_src_reg_observe_fifo_thresh

  class entropy_src_reg_observe_fifo_depth extends dv_base_reg;
    // fields
    rand dv_base_reg_field observe_fifo_depth;

    `uvm_object_utils(entropy_src_reg_observe_fifo_depth)

    function new(string       name = "entropy_src_reg_observe_fifo_depth",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      observe_fifo_depth =
          (dv_base_reg_field::
           type_id::create("observe_fifo_depth"));
      observe_fifo_depth.configure(
        .parent(this),
        .size(6),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      observe_fifo_depth.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_observe_fifo_depth

  class entropy_src_reg_debug_status extends dv_base_reg;
    // fields
    rand dv_base_reg_field entropy_fifo_depth;
    rand dv_base_reg_field sha3_fsm;
    rand dv_base_reg_field sha3_block_pr;
    rand dv_base_reg_field sha3_squeezing;
    rand dv_base_reg_field sha3_absorbed;
    rand dv_base_reg_field sha3_err;
    rand dv_base_reg_field main_sm_idle;
    rand dv_base_reg_field main_sm_boot_done;

    `uvm_object_utils(entropy_src_reg_debug_status)

    function new(string       name = "entropy_src_reg_debug_status",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      entropy_fifo_depth =
          (dv_base_reg_field::
           type_id::create("entropy_fifo_depth"));
      entropy_fifo_depth.configure(
        .parent(this),
        .size(2),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_fifo_depth.set_original_access("RO");
      sha3_fsm =
          (dv_base_reg_field::
           type_id::create("sha3_fsm"));
      sha3_fsm.configure(
        .parent(this),
        .size(3),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_fsm.set_original_access("RO");
      sha3_block_pr =
          (dv_base_reg_field::
           type_id::create("sha3_block_pr"));
      sha3_block_pr.configure(
        .parent(this),
        .size(1),
        .lsb_pos(6),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_block_pr.set_original_access("RO");
      sha3_squeezing =
          (dv_base_reg_field::
           type_id::create("sha3_squeezing"));
      sha3_squeezing.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_squeezing.set_original_access("RO");
      sha3_absorbed =
          (dv_base_reg_field::
           type_id::create("sha3_absorbed"));
      sha3_absorbed.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_absorbed.set_original_access("RO");
      sha3_err =
          (dv_base_reg_field::
           type_id::create("sha3_err"));
      sha3_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_err.set_original_access("RO");
      main_sm_idle =
          (dv_base_reg_field::
           type_id::create("main_sm_idle"));
      main_sm_idle.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_idle.set_original_access("RO");
      main_sm_boot_done =
          (dv_base_reg_field::
           type_id::create("main_sm_boot_done"));
      main_sm_boot_done.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_boot_done.set_original_access("RO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : entropy_src_reg_debug_status

  class entropy_src_reg_recov_alert_sts extends dv_base_reg;
    // fields
    rand dv_base_reg_field fips_enable_field_alert;
    rand dv_base_reg_field entropy_data_reg_en_field_alert;
    rand dv_base_reg_field module_enable_field_alert;
    rand dv_base_reg_field threshold_scope_field_alert;
    rand dv_base_reg_field rng_bit_enable_field_alert;
    rand dv_base_reg_field fw_ov_sha3_start_field_alert;
    rand dv_base_reg_field fw_ov_mode_field_alert;
    rand dv_base_reg_field fw_ov_entropy_insert_field_alert;
    rand dv_base_reg_field es_route_field_alert;
    rand dv_base_reg_field es_type_field_alert;
    rand dv_base_reg_field es_main_sm_alert;
    rand dv_base_reg_field es_bus_cmp_alert;
    rand dv_base_reg_field es_thresh_cfg_alert;
    rand dv_base_reg_field es_fw_ov_wr_alert;
    rand dv_base_reg_field es_fw_ov_disable_alert;
    rand dv_base_reg_field fips_flag_field_alert;
    rand dv_base_reg_field rng_fips_field_alert;
    rand dv_base_reg_field postht_entropy_drop_alert;

    `uvm_object_utils(entropy_src_reg_recov_alert_sts)

    function new(string       name = "entropy_src_reg_recov_alert_sts",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fips_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("fips_enable_field_alert"));
      fips_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_enable_field_alert.set_original_access("W0C");
      entropy_data_reg_en_field_alert =
          (dv_base_reg_field::
           type_id::create("entropy_data_reg_en_field_alert"));
      entropy_data_reg_en_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      entropy_data_reg_en_field_alert.set_original_access("W0C");
      module_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("module_enable_field_alert"));
      module_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      module_enable_field_alert.set_original_access("W0C");
      threshold_scope_field_alert =
          (dv_base_reg_field::
           type_id::create("threshold_scope_field_alert"));
      threshold_scope_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold_scope_field_alert.set_original_access("W0C");
      rng_bit_enable_field_alert =
          (dv_base_reg_field::
           type_id::create("rng_bit_enable_field_alert"));
      rng_bit_enable_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(5),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rng_bit_enable_field_alert.set_original_access("W0C");
      fw_ov_sha3_start_field_alert =
          (dv_base_reg_field::
           type_id::create("fw_ov_sha3_start_field_alert"));
      fw_ov_sha3_start_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(7),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_sha3_start_field_alert.set_original_access("W0C");
      fw_ov_mode_field_alert =
          (dv_base_reg_field::
           type_id::create("fw_ov_mode_field_alert"));
      fw_ov_mode_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(8),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_mode_field_alert.set_original_access("W0C");
      fw_ov_entropy_insert_field_alert =
          (dv_base_reg_field::
           type_id::create("fw_ov_entropy_insert_field_alert"));
      fw_ov_entropy_insert_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(9),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fw_ov_entropy_insert_field_alert.set_original_access("W0C");
      es_route_field_alert =
          (dv_base_reg_field::
           type_id::create("es_route_field_alert"));
      es_route_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(10),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_route_field_alert.set_original_access("W0C");
      es_type_field_alert =
          (dv_base_reg_field::
           type_id::create("es_type_field_alert"));
      es_type_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(11),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_type_field_alert.set_original_access("W0C");
      es_main_sm_alert =
          (dv_base_reg_field::
           type_id::create("es_main_sm_alert"));
      es_main_sm_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(12),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_main_sm_alert.set_original_access("W0C");
      es_bus_cmp_alert =
          (dv_base_reg_field::
           type_id::create("es_bus_cmp_alert"));
      es_bus_cmp_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(13),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_bus_cmp_alert.set_original_access("W0C");
      es_thresh_cfg_alert =
          (dv_base_reg_field::
           type_id::create("es_thresh_cfg_alert"));
      es_thresh_cfg_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(14),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_thresh_cfg_alert.set_original_access("W0C");
      es_fw_ov_wr_alert =
          (dv_base_reg_field::
           type_id::create("es_fw_ov_wr_alert"));
      es_fw_ov_wr_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(15),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_fw_ov_wr_alert.set_original_access("W0C");
      es_fw_ov_disable_alert =
          (dv_base_reg_field::
           type_id::create("es_fw_ov_disable_alert"));
      es_fw_ov_disable_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(16),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_fw_ov_disable_alert.set_original_access("W0C");
      fips_flag_field_alert =
          (dv_base_reg_field::
           type_id::create("fips_flag_field_alert"));
      fips_flag_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(17),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fips_flag_field_alert.set_original_access("W0C");
      rng_fips_field_alert =
          (dv_base_reg_field::
           type_id::create("rng_fips_field_alert"));
      rng_fips_field_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(18),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      rng_fips_field_alert.set_original_access("W0C");
      postht_entropy_drop_alert =
          (dv_base_reg_field::
           type_id::create("postht_entropy_drop_alert"));
      postht_entropy_drop_alert.configure(
        .parent(this),
        .size(1),
        .lsb_pos(31),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      postht_entropy_drop_alert.set_original_access("W0C");
    endfunction : build
  endclass : entropy_src_reg_recov_alert_sts

  class entropy_src_reg_err_code extends dv_base_reg;
    // fields
    rand dv_base_reg_field sfifo_esrng_err;
    rand dv_base_reg_field sfifo_distr_err;
    rand dv_base_reg_field sfifo_observe_err;
    rand dv_base_reg_field sfifo_esfinal_err;
    rand dv_base_reg_field es_ack_sm_err;
    rand dv_base_reg_field es_main_sm_err;
    rand dv_base_reg_field es_cntr_err;
    rand dv_base_reg_field sha3_state_err;
    rand dv_base_reg_field sha3_rst_storage_err;
    rand dv_base_reg_field fifo_write_err;
    rand dv_base_reg_field fifo_read_err;
    rand dv_base_reg_field fifo_state_err;

    `uvm_object_utils(entropy_src_reg_err_code)

    function new(string       name = "entropy_src_reg_err_code",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      sfifo_esrng_err =
          (dv_base_reg_field::
           type_id::create("sfifo_esrng_err"));
      sfifo_esrng_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_esrng_err.set_original_access("RO");
      sfifo_distr_err =
          (dv_base_reg_field::
           type_id::create("sfifo_distr_err"));
      sfifo_distr_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_distr_err.set_original_access("RO");
      sfifo_observe_err =
          (dv_base_reg_field::
           type_id::create("sfifo_observe_err"));
      sfifo_observe_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(2),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_observe_err.set_original_access("RO");
      sfifo_esfinal_err =
          (dv_base_reg_field::
           type_id::create("sfifo_esfinal_err"));
      sfifo_esfinal_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(3),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sfifo_esfinal_err.set_original_access("RO");
      es_ack_sm_err =
          (dv_base_reg_field::
           type_id::create("es_ack_sm_err"));
      es_ack_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(20),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_ack_sm_err.set_original_access("RO");
      es_main_sm_err =
          (dv_base_reg_field::
           type_id::create("es_main_sm_err"));
      es_main_sm_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(21),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_main_sm_err.set_original_access("RO");
      es_cntr_err =
          (dv_base_reg_field::
           type_id::create("es_cntr_err"));
      es_cntr_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(22),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      es_cntr_err.set_original_access("RO");
      sha3_state_err =
          (dv_base_reg_field::
           type_id::create("sha3_state_err"));
      sha3_state_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(23),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_state_err.set_original_access("RO");
      sha3_rst_storage_err =
          (dv_base_reg_field::
           type_id::create("sha3_rst_storage_err"));
      sha3_rst_storage_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(24),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      sha3_rst_storage_err.set_original_access("RO");
      fifo_write_err =
          (dv_base_reg_field::
           type_id::create("fifo_write_err"));
      fifo_write_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(28),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_write_err.set_original_access("RO");
      fifo_read_err =
          (dv_base_reg_field::
           type_id::create("fifo_read_err"));
      fifo_read_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(29),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_read_err.set_original_access("RO");
      fifo_state_err =
          (dv_base_reg_field::
           type_id::create("fifo_state_err"));
      fifo_state_err.configure(
        .parent(this),
        .size(1),
        .lsb_pos(30),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fifo_state_err.set_original_access("RO");
    endfunction : build
  endclass : entropy_src_reg_err_code

  class entropy_src_reg_err_code_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field err_code_test;

    `uvm_object_utils(entropy_src_reg_err_code_test)

    function new(string       name = "entropy_src_reg_err_code_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      err_code_test =
          (dv_base_reg_field::
           type_id::create("err_code_test"));
      err_code_test.configure(
        .parent(this),
        .size(5),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      err_code_test.set_original_access("RW");
    endfunction : build
  endclass : entropy_src_reg_err_code_test

  class entropy_src_reg_main_sm_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field main_sm_state;

    `uvm_object_utils(entropy_src_reg_main_sm_state)

    function new(string       name = "entropy_src_reg_main_sm_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      main_sm_state =
          (dv_base_reg_field::
           type_id::create("main_sm_state"));
      main_sm_state.configure(
        .parent(this),
        .size(9),
        .lsb_pos(0),
        .access("RO"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'hf5),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      main_sm_state.set_original_access("RO");
    endfunction : build
  endclass : entropy_src_reg_main_sm_state

  class entropy_src_reg_block extends dv_base_reg_block;
    // registers
    rand entropy_src_reg_intr_state intr_state;
    rand entropy_src_reg_intr_enable intr_enable;
    rand entropy_src_reg_intr_test intr_test;
    rand entropy_src_reg_alert_test alert_test;
    rand entropy_src_reg_me_regwen me_regwen;
    rand entropy_src_reg_sw_regupd sw_regupd;
    rand entropy_src_reg_regwen regwen;
    rand entropy_src_reg_rev rev;
    rand entropy_src_reg_module_enable module_enable;
    rand entropy_src_reg_conf conf;
    rand entropy_src_reg_entropy_control entropy_control;
    rand entropy_src_reg_entropy_data entropy_data;
    rand entropy_src_reg_health_test_windows health_test_windows;
    rand entropy_src_reg_repcnt_thresholds repcnt_thresholds;
    rand entropy_src_reg_repcnts_thresholds repcnts_thresholds;
    rand entropy_src_reg_adaptp_hi_thresholds adaptp_hi_thresholds;
    rand entropy_src_reg_adaptp_lo_thresholds adaptp_lo_thresholds;
    rand entropy_src_reg_bucket_thresholds bucket_thresholds;
    rand entropy_src_reg_markov_hi_thresholds markov_hi_thresholds;
    rand entropy_src_reg_markov_lo_thresholds markov_lo_thresholds;
    rand entropy_src_reg_extht_hi_thresholds extht_hi_thresholds;
    rand entropy_src_reg_extht_lo_thresholds extht_lo_thresholds;
    rand entropy_src_reg_repcnt_hi_watermarks repcnt_hi_watermarks;
    rand entropy_src_reg_repcnts_hi_watermarks repcnts_hi_watermarks;
    rand entropy_src_reg_adaptp_hi_watermarks adaptp_hi_watermarks;
    rand entropy_src_reg_adaptp_lo_watermarks adaptp_lo_watermarks;
    rand entropy_src_reg_extht_hi_watermarks extht_hi_watermarks;
    rand entropy_src_reg_extht_lo_watermarks extht_lo_watermarks;
    rand entropy_src_reg_bucket_hi_watermarks bucket_hi_watermarks;
    rand entropy_src_reg_markov_hi_watermarks markov_hi_watermarks;
    rand entropy_src_reg_markov_lo_watermarks markov_lo_watermarks;
    rand entropy_src_reg_repcnt_total_fails repcnt_total_fails;
    rand entropy_src_reg_repcnts_total_fails repcnts_total_fails;
    rand entropy_src_reg_adaptp_hi_total_fails adaptp_hi_total_fails;
    rand entropy_src_reg_adaptp_lo_total_fails adaptp_lo_total_fails;
    rand entropy_src_reg_bucket_total_fails bucket_total_fails;
    rand entropy_src_reg_markov_hi_total_fails markov_hi_total_fails;
    rand entropy_src_reg_markov_lo_total_fails markov_lo_total_fails;
    rand entropy_src_reg_extht_hi_total_fails extht_hi_total_fails;
    rand entropy_src_reg_extht_lo_total_fails extht_lo_total_fails;
    rand entropy_src_reg_alert_threshold alert_threshold;
    rand entropy_src_reg_alert_summary_fail_counts alert_summary_fail_counts;
    rand entropy_src_reg_alert_fail_counts alert_fail_counts;
    rand entropy_src_reg_extht_fail_counts extht_fail_counts;
    rand entropy_src_reg_fw_ov_control fw_ov_control;
    rand entropy_src_reg_fw_ov_sha3_start fw_ov_sha3_start;
    rand entropy_src_reg_fw_ov_wr_fifo_full fw_ov_wr_fifo_full;
    rand entropy_src_reg_fw_ov_rd_fifo_overflow fw_ov_rd_fifo_overflow;
    rand entropy_src_reg_fw_ov_rd_data fw_ov_rd_data;
    rand entropy_src_reg_fw_ov_wr_data fw_ov_wr_data;
    rand entropy_src_reg_observe_fifo_thresh observe_fifo_thresh;
    rand entropy_src_reg_observe_fifo_depth observe_fifo_depth;
    rand entropy_src_reg_debug_status debug_status;
    rand entropy_src_reg_recov_alert_sts recov_alert_sts;
    rand entropy_src_reg_err_code err_code;
    rand entropy_src_reg_err_code_test err_code_test;
    rand entropy_src_reg_main_sm_state main_sm_state;

    `uvm_object_utils(entropy_src_reg_block)

    function new(string name = "entropy_src_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      intr_state =
          (entropy_src_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h0));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_es_entropy_valid.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_es_health_test_failed.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_es_observe_fifo_ready.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_es_fatal_err.q",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclAll, CsrAllTests);
      intr_enable =
          (entropy_src_reg_intr_enable::
           type_id::create("intr_enable"));
      intr_enable.configure(.blk_parent(this));
      intr_enable.build(csr_excl);
      default_map.add_reg(.rg(intr_enable),
                          .offset(32'h4));
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_es_entropy_valid.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_es_health_test_failed.q",
          1, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_es_observe_fifo_ready.q",
          2, 1, 0, "BkdrRegPathRtl");
      intr_enable.add_hdl_path_slice(
          "u_reg.u_intr_enable_es_fatal_err.q",
          3, 1, 0, "BkdrRegPathRtl");

      intr_test =
          (entropy_src_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h8));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_es_entropy_valid.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_es_health_test_failed.qs",
          1, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_es_observe_fifo_ready.qs",
          2, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_es_fatal_err.qs",
          3, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_test =
          (entropy_src_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'hc));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_recov_alert.qs",
          0, 1, 0, "BkdrRegPathRtl");
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test_fatal_alert.qs",
          1, 1, 0, "BkdrRegPathRtl");

      me_regwen =
          (entropy_src_reg_me_regwen::
           type_id::create("me_regwen"));
      me_regwen.configure(.blk_parent(this));
      me_regwen.build(csr_excl);
      default_map.add_reg(.rg(me_regwen),
                          .offset(32'h10));
      me_regwen.add_hdl_path_slice(
          "u_reg.u_me_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      sw_regupd =
          (entropy_src_reg_sw_regupd::
           type_id::create("sw_regupd"));
      sw_regupd.configure(.blk_parent(this));
      sw_regupd.build(csr_excl);
      default_map.add_reg(.rg(sw_regupd),
                          .offset(32'h14));
      sw_regupd.add_hdl_path_slice(
          "u_reg.u_sw_regupd.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(sw_regupd.get_full_name(),
                        CsrExclAll, CsrAllTests);
      regwen =
          (entropy_src_reg_regwen::
           type_id::create("regwen"));
      regwen.configure(.blk_parent(this));
      regwen.build(csr_excl);
      default_map.add_reg(.rg(regwen),
                          .offset(32'h18));
      regwen.add_hdl_path_slice(
          "u_reg.u_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(regwen.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      rev =
          (entropy_src_reg_rev::
           type_id::create("rev"));
      rev.configure(.blk_parent(this));
      rev.build(csr_excl);
      default_map.add_reg(.rg(rev),
                          .offset(32'h1c));
      // constant reg
      rev.add_hdl_path_slice(
          "u_reg.rev_abi_revision_qs",
          0, 8, 0, "BkdrRegPathRtl");
      // constant reg
      rev.add_hdl_path_slice(
          "u_reg.rev_hw_revision_qs",
          8, 8, 0, "BkdrRegPathRtl");
      // constant reg
      rev.add_hdl_path_slice(
          "u_reg.rev_chip_type_qs",
          16, 8, 0, "BkdrRegPathRtl");

      module_enable =
          (entropy_src_reg_module_enable::
           type_id::create("module_enable"));
      module_enable.configure(.blk_parent(this));
      module_enable.build(csr_excl);
      default_map.add_reg(.rg(module_enable),
                          .offset(32'h20));
      module_enable.add_hdl_path_slice(
          "u_reg.u_module_enable.q",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(module_enable.get_full_name(),
                        CsrExclAll, CsrAllTests);
      conf =
          (entropy_src_reg_conf::
           type_id::create("conf"));
      conf.configure(.blk_parent(this));
      conf.build(csr_excl);
      default_map.add_reg(.rg(conf),
                          .offset(32'h24));
      conf.add_hdl_path_slice(
          "u_reg.u_conf_fips_enable.q",
          0, 4, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_fips_flag.q",
          4, 4, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_rng_fips.q",
          8, 4, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_rng_bit_enable.q",
          12, 4, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_rng_bit_sel.q",
          16, 2, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_threshold_scope.q",
          18, 4, 0, "BkdrRegPathRtl");
      conf.add_hdl_path_slice(
          "u_reg.u_conf_entropy_data_reg_enable.q",
          22, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(conf.get_full_name(),
                        CsrExclAll, CsrAllTests);
      entropy_control =
          (entropy_src_reg_entropy_control::
           type_id::create("entropy_control"));
      entropy_control.configure(.blk_parent(this));
      entropy_control.build(csr_excl);
      default_map.add_reg(.rg(entropy_control),
                          .offset(32'h28));
      entropy_control.add_hdl_path_slice(
          "u_reg.u_entropy_control_es_route.q",
          0, 4, 0, "BkdrRegPathRtl");
      entropy_control.add_hdl_path_slice(
          "u_reg.u_entropy_control_es_type.q",
          4, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(entropy_control.get_full_name(),
                        CsrExclAll, CsrAllTests);
      entropy_data =
          (entropy_src_reg_entropy_data::
           type_id::create("entropy_data"));
      entropy_data.configure(.blk_parent(this));
      entropy_data.build(csr_excl);
      default_map.add_reg(.rg(entropy_data),
                          .offset(32'h2c));
      entropy_data.add_hdl_path_slice(
          "u_reg.u_entropy_data.qs",
          0, 32, 0, "BkdrRegPathRtl");

      health_test_windows =
          (entropy_src_reg_health_test_windows::
           type_id::create("health_test_windows"));
      health_test_windows.configure(.blk_parent(this));
      health_test_windows.build(csr_excl);
      default_map.add_reg(.rg(health_test_windows),
                          .offset(32'h30));
      health_test_windows.add_hdl_path_slice(
          "u_reg.u_health_test_windows_fips_window.q",
          0, 16, 0, "BkdrRegPathRtl");
      health_test_windows.add_hdl_path_slice(
          "u_reg.u_health_test_windows_bypass_window.q",
          16, 16, 0, "BkdrRegPathRtl");

      repcnt_thresholds =
          (entropy_src_reg_repcnt_thresholds::
           type_id::create("repcnt_thresholds"));
      repcnt_thresholds.configure(.blk_parent(this));
      repcnt_thresholds.build(csr_excl);
      default_map.add_reg(.rg(repcnt_thresholds),
                          .offset(32'h34));
      repcnt_thresholds.add_hdl_path_slice(
          "u_reg.u_repcnt_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      repcnt_thresholds.add_hdl_path_slice(
          "u_reg.u_repcnt_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(repcnt_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      repcnts_thresholds =
          (entropy_src_reg_repcnts_thresholds::
           type_id::create("repcnts_thresholds"));
      repcnts_thresholds.configure(.blk_parent(this));
      repcnts_thresholds.build(csr_excl);
      default_map.add_reg(.rg(repcnts_thresholds),
                          .offset(32'h38));
      repcnts_thresholds.add_hdl_path_slice(
          "u_reg.u_repcnts_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      repcnts_thresholds.add_hdl_path_slice(
          "u_reg.u_repcnts_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(repcnts_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      adaptp_hi_thresholds =
          (entropy_src_reg_adaptp_hi_thresholds::
           type_id::create("adaptp_hi_thresholds"));
      adaptp_hi_thresholds.configure(.blk_parent(this));
      adaptp_hi_thresholds.build(csr_excl);
      default_map.add_reg(.rg(adaptp_hi_thresholds),
                          .offset(32'h3c));
      adaptp_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_adaptp_hi_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      adaptp_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_adaptp_hi_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adaptp_hi_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      adaptp_lo_thresholds =
          (entropy_src_reg_adaptp_lo_thresholds::
           type_id::create("adaptp_lo_thresholds"));
      adaptp_lo_thresholds.configure(.blk_parent(this));
      adaptp_lo_thresholds.build(csr_excl);
      default_map.add_reg(.rg(adaptp_lo_thresholds),
                          .offset(32'h40));
      adaptp_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_adaptp_lo_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      adaptp_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_adaptp_lo_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adaptp_lo_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      bucket_thresholds =
          (entropy_src_reg_bucket_thresholds::
           type_id::create("bucket_thresholds"));
      bucket_thresholds.configure(.blk_parent(this));
      bucket_thresholds.build(csr_excl);
      default_map.add_reg(.rg(bucket_thresholds),
                          .offset(32'h44));
      bucket_thresholds.add_hdl_path_slice(
          "u_reg.u_bucket_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      bucket_thresholds.add_hdl_path_slice(
          "u_reg.u_bucket_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(bucket_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      markov_hi_thresholds =
          (entropy_src_reg_markov_hi_thresholds::
           type_id::create("markov_hi_thresholds"));
      markov_hi_thresholds.configure(.blk_parent(this));
      markov_hi_thresholds.build(csr_excl);
      default_map.add_reg(.rg(markov_hi_thresholds),
                          .offset(32'h48));
      markov_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_markov_hi_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      markov_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_markov_hi_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(markov_hi_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      markov_lo_thresholds =
          (entropy_src_reg_markov_lo_thresholds::
           type_id::create("markov_lo_thresholds"));
      markov_lo_thresholds.configure(.blk_parent(this));
      markov_lo_thresholds.build(csr_excl);
      default_map.add_reg(.rg(markov_lo_thresholds),
                          .offset(32'h4c));
      markov_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_markov_lo_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      markov_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_markov_lo_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(markov_lo_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      extht_hi_thresholds =
          (entropy_src_reg_extht_hi_thresholds::
           type_id::create("extht_hi_thresholds"));
      extht_hi_thresholds.configure(.blk_parent(this));
      extht_hi_thresholds.build(csr_excl);
      default_map.add_reg(.rg(extht_hi_thresholds),
                          .offset(32'h50));
      extht_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_extht_hi_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      extht_hi_thresholds.add_hdl_path_slice(
          "u_reg.u_extht_hi_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(extht_hi_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      extht_lo_thresholds =
          (entropy_src_reg_extht_lo_thresholds::
           type_id::create("extht_lo_thresholds"));
      extht_lo_thresholds.configure(.blk_parent(this));
      extht_lo_thresholds.build(csr_excl);
      default_map.add_reg(.rg(extht_lo_thresholds),
                          .offset(32'h54));
      extht_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_extht_lo_thresholds_fips_thresh.qs",
          0, 16, 0, "BkdrRegPathRtl");
      extht_lo_thresholds.add_hdl_path_slice(
          "u_reg.u_extht_lo_thresholds_bypass_thresh.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(extht_lo_thresholds.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      repcnt_hi_watermarks =
          (entropy_src_reg_repcnt_hi_watermarks::
           type_id::create("repcnt_hi_watermarks"));
      repcnt_hi_watermarks.configure(.blk_parent(this));
      repcnt_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(repcnt_hi_watermarks),
                          .offset(32'h58));
      repcnt_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_repcnt_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      repcnt_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_repcnt_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(repcnt_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      repcnts_hi_watermarks =
          (entropy_src_reg_repcnts_hi_watermarks::
           type_id::create("repcnts_hi_watermarks"));
      repcnts_hi_watermarks.configure(.blk_parent(this));
      repcnts_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(repcnts_hi_watermarks),
                          .offset(32'h5c));
      repcnts_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_repcnts_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      repcnts_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_repcnts_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(repcnts_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrAllTests);
      adaptp_hi_watermarks =
          (entropy_src_reg_adaptp_hi_watermarks::
           type_id::create("adaptp_hi_watermarks"));
      adaptp_hi_watermarks.configure(.blk_parent(this));
      adaptp_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(adaptp_hi_watermarks),
                          .offset(32'h60));
      adaptp_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_adaptp_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      adaptp_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_adaptp_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adaptp_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      adaptp_lo_watermarks =
          (entropy_src_reg_adaptp_lo_watermarks::
           type_id::create("adaptp_lo_watermarks"));
      adaptp_lo_watermarks.configure(.blk_parent(this));
      adaptp_lo_watermarks.build(csr_excl);
      default_map.add_reg(.rg(adaptp_lo_watermarks),
                          .offset(32'h64));
      adaptp_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_adaptp_lo_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      adaptp_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_adaptp_lo_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(adaptp_lo_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      extht_hi_watermarks =
          (entropy_src_reg_extht_hi_watermarks::
           type_id::create("extht_hi_watermarks"));
      extht_hi_watermarks.configure(.blk_parent(this));
      extht_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(extht_hi_watermarks),
                          .offset(32'h68));
      extht_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_extht_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      extht_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_extht_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(extht_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      extht_lo_watermarks =
          (entropy_src_reg_extht_lo_watermarks::
           type_id::create("extht_lo_watermarks"));
      extht_lo_watermarks.configure(.blk_parent(this));
      extht_lo_watermarks.build(csr_excl);
      default_map.add_reg(.rg(extht_lo_watermarks),
                          .offset(32'h6c));
      extht_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_extht_lo_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      extht_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_extht_lo_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(extht_lo_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      bucket_hi_watermarks =
          (entropy_src_reg_bucket_hi_watermarks::
           type_id::create("bucket_hi_watermarks"));
      bucket_hi_watermarks.configure(.blk_parent(this));
      bucket_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(bucket_hi_watermarks),
                          .offset(32'h70));
      bucket_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_bucket_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      bucket_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_bucket_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(bucket_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      markov_hi_watermarks =
          (entropy_src_reg_markov_hi_watermarks::
           type_id::create("markov_hi_watermarks"));
      markov_hi_watermarks.configure(.blk_parent(this));
      markov_hi_watermarks.build(csr_excl);
      default_map.add_reg(.rg(markov_hi_watermarks),
                          .offset(32'h74));
      markov_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_markov_hi_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      markov_hi_watermarks.add_hdl_path_slice(
          "u_reg.u_markov_hi_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(markov_hi_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      markov_lo_watermarks =
          (entropy_src_reg_markov_lo_watermarks::
           type_id::create("markov_lo_watermarks"));
      markov_lo_watermarks.configure(.blk_parent(this));
      markov_lo_watermarks.build(csr_excl);
      default_map.add_reg(.rg(markov_lo_watermarks),
                          .offset(32'h78));
      markov_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_markov_lo_watermarks_fips_watermark.qs",
          0, 16, 0, "BkdrRegPathRtl");
      markov_lo_watermarks.add_hdl_path_slice(
          "u_reg.u_markov_lo_watermarks_bypass_watermark.qs",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(markov_lo_watermarks.get_full_name(),
                        CsrExclCheck, CsrNonInitTests);
      repcnt_total_fails =
          (entropy_src_reg_repcnt_total_fails::
           type_id::create("repcnt_total_fails"));
      repcnt_total_fails.configure(.blk_parent(this));
      repcnt_total_fails.build(csr_excl);
      default_map.add_reg(.rg(repcnt_total_fails),
                          .offset(32'h7c));
      repcnt_total_fails.add_hdl_path_slice(
          "u_reg.u_repcnt_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      repcnts_total_fails =
          (entropy_src_reg_repcnts_total_fails::
           type_id::create("repcnts_total_fails"));
      repcnts_total_fails.configure(.blk_parent(this));
      repcnts_total_fails.build(csr_excl);
      default_map.add_reg(.rg(repcnts_total_fails),
                          .offset(32'h80));
      repcnts_total_fails.add_hdl_path_slice(
          "u_reg.u_repcnts_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      adaptp_hi_total_fails =
          (entropy_src_reg_adaptp_hi_total_fails::
           type_id::create("adaptp_hi_total_fails"));
      adaptp_hi_total_fails.configure(.blk_parent(this));
      adaptp_hi_total_fails.build(csr_excl);
      default_map.add_reg(.rg(adaptp_hi_total_fails),
                          .offset(32'h84));
      adaptp_hi_total_fails.add_hdl_path_slice(
          "u_reg.u_adaptp_hi_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      adaptp_lo_total_fails =
          (entropy_src_reg_adaptp_lo_total_fails::
           type_id::create("adaptp_lo_total_fails"));
      adaptp_lo_total_fails.configure(.blk_parent(this));
      adaptp_lo_total_fails.build(csr_excl);
      default_map.add_reg(.rg(adaptp_lo_total_fails),
                          .offset(32'h88));
      adaptp_lo_total_fails.add_hdl_path_slice(
          "u_reg.u_adaptp_lo_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      bucket_total_fails =
          (entropy_src_reg_bucket_total_fails::
           type_id::create("bucket_total_fails"));
      bucket_total_fails.configure(.blk_parent(this));
      bucket_total_fails.build(csr_excl);
      default_map.add_reg(.rg(bucket_total_fails),
                          .offset(32'h8c));
      bucket_total_fails.add_hdl_path_slice(
          "u_reg.u_bucket_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      markov_hi_total_fails =
          (entropy_src_reg_markov_hi_total_fails::
           type_id::create("markov_hi_total_fails"));
      markov_hi_total_fails.configure(.blk_parent(this));
      markov_hi_total_fails.build(csr_excl);
      default_map.add_reg(.rg(markov_hi_total_fails),
                          .offset(32'h90));
      markov_hi_total_fails.add_hdl_path_slice(
          "u_reg.u_markov_hi_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      markov_lo_total_fails =
          (entropy_src_reg_markov_lo_total_fails::
           type_id::create("markov_lo_total_fails"));
      markov_lo_total_fails.configure(.blk_parent(this));
      markov_lo_total_fails.build(csr_excl);
      default_map.add_reg(.rg(markov_lo_total_fails),
                          .offset(32'h94));
      markov_lo_total_fails.add_hdl_path_slice(
          "u_reg.u_markov_lo_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      extht_hi_total_fails =
          (entropy_src_reg_extht_hi_total_fails::
           type_id::create("extht_hi_total_fails"));
      extht_hi_total_fails.configure(.blk_parent(this));
      extht_hi_total_fails.build(csr_excl);
      default_map.add_reg(.rg(extht_hi_total_fails),
                          .offset(32'h98));
      extht_hi_total_fails.add_hdl_path_slice(
          "u_reg.u_extht_hi_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      extht_lo_total_fails =
          (entropy_src_reg_extht_lo_total_fails::
           type_id::create("extht_lo_total_fails"));
      extht_lo_total_fails.configure(.blk_parent(this));
      extht_lo_total_fails.build(csr_excl);
      default_map.add_reg(.rg(extht_lo_total_fails),
                          .offset(32'h9c));
      extht_lo_total_fails.add_hdl_path_slice(
          "u_reg.u_extht_lo_total_fails.qs",
          0, 32, 0, "BkdrRegPathRtl");

      alert_threshold =
          (entropy_src_reg_alert_threshold::
           type_id::create("alert_threshold"));
      alert_threshold.configure(.blk_parent(this));
      alert_threshold.build(csr_excl);
      default_map.add_reg(.rg(alert_threshold),
                          .offset(32'ha0));
      alert_threshold.add_hdl_path_slice(
          "u_reg.u_alert_threshold_alert_threshold.q",
          0, 16, 0, "BkdrRegPathRtl");
      alert_threshold.add_hdl_path_slice(
          "u_reg.u_alert_threshold_alert_threshold_inv.q",
          16, 16, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(alert_threshold.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      alert_summary_fail_counts =
          (entropy_src_reg_alert_summary_fail_counts::
           type_id::create("alert_summary_fail_counts"));
      alert_summary_fail_counts.configure(.blk_parent(this));
      alert_summary_fail_counts.build(csr_excl);
      default_map.add_reg(.rg(alert_summary_fail_counts),
                          .offset(32'ha4));
      alert_summary_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_summary_fail_counts.qs",
          0, 16, 0, "BkdrRegPathRtl");

      alert_fail_counts =
          (entropy_src_reg_alert_fail_counts::
           type_id::create("alert_fail_counts"));
      alert_fail_counts.configure(.blk_parent(this));
      alert_fail_counts.build(csr_excl);
      default_map.add_reg(.rg(alert_fail_counts),
                          .offset(32'ha8));
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_repcnt_fail_count.qs",
          4, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_adaptp_hi_fail_count.qs",
          8, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_adaptp_lo_fail_count.qs",
          12, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_bucket_fail_count.qs",
          16, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_markov_hi_fail_count.qs",
          20, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_markov_lo_fail_count.qs",
          24, 4, 0, "BkdrRegPathRtl");
      alert_fail_counts.add_hdl_path_slice(
          "u_reg.u_alert_fail_counts_repcnts_fail_count.qs",
          28, 4, 0, "BkdrRegPathRtl");

      extht_fail_counts =
          (entropy_src_reg_extht_fail_counts::
           type_id::create("extht_fail_counts"));
      extht_fail_counts.configure(.blk_parent(this));
      extht_fail_counts.build(csr_excl);
      default_map.add_reg(.rg(extht_fail_counts),
                          .offset(32'hac));
      extht_fail_counts.add_hdl_path_slice(
          "u_reg.u_extht_fail_counts_extht_hi_fail_count.qs",
          0, 4, 0, "BkdrRegPathRtl");
      extht_fail_counts.add_hdl_path_slice(
          "u_reg.u_extht_fail_counts_extht_lo_fail_count.qs",
          4, 4, 0, "BkdrRegPathRtl");

      fw_ov_control =
          (entropy_src_reg_fw_ov_control::
           type_id::create("fw_ov_control"));
      fw_ov_control.configure(.blk_parent(this));
      fw_ov_control.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_control),
                          .offset(32'hb0));
      fw_ov_control.add_hdl_path_slice(
          "u_reg.u_fw_ov_control_fw_ov_mode.q",
          0, 4, 0, "BkdrRegPathRtl");
      fw_ov_control.add_hdl_path_slice(
          "u_reg.u_fw_ov_control_fw_ov_entropy_insert.q",
          4, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(fw_ov_control.get_full_name(),
                        CsrExclAll, CsrAllTests);
      fw_ov_sha3_start =
          (entropy_src_reg_fw_ov_sha3_start::
           type_id::create("fw_ov_sha3_start"));
      fw_ov_sha3_start.configure(.blk_parent(this));
      fw_ov_sha3_start.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_sha3_start),
                          .offset(32'hb4));
      fw_ov_sha3_start.add_hdl_path_slice(
          "u_reg.u_fw_ov_sha3_start.q",
          0, 4, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(fw_ov_sha3_start.get_full_name(),
                        CsrExclAll, CsrAllTests);
      fw_ov_wr_fifo_full =
          (entropy_src_reg_fw_ov_wr_fifo_full::
           type_id::create("fw_ov_wr_fifo_full"));
      fw_ov_wr_fifo_full.configure(.blk_parent(this));
      fw_ov_wr_fifo_full.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_wr_fifo_full),
                          .offset(32'hb8));
      fw_ov_wr_fifo_full.add_hdl_path_slice(
          "u_reg.u_fw_ov_wr_fifo_full.qs",
          0, 1, 0, "BkdrRegPathRtl");

      fw_ov_rd_fifo_overflow =
          (entropy_src_reg_fw_ov_rd_fifo_overflow::
           type_id::create("fw_ov_rd_fifo_overflow"));
      fw_ov_rd_fifo_overflow.configure(.blk_parent(this));
      fw_ov_rd_fifo_overflow.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_rd_fifo_overflow),
                          .offset(32'hbc));
      fw_ov_rd_fifo_overflow.add_hdl_path_slice(
          "u_reg.u_fw_ov_rd_fifo_overflow.q",
          0, 1, 0, "BkdrRegPathRtl");

      fw_ov_rd_data =
          (entropy_src_reg_fw_ov_rd_data::
           type_id::create("fw_ov_rd_data"));
      fw_ov_rd_data.configure(.blk_parent(this));
      fw_ov_rd_data.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_rd_data),
                          .offset(32'hc0));
      fw_ov_rd_data.add_hdl_path_slice(
          "u_reg.u_fw_ov_rd_data.qs",
          0, 32, 0, "BkdrRegPathRtl");

      fw_ov_wr_data =
          (entropy_src_reg_fw_ov_wr_data::
           type_id::create("fw_ov_wr_data"));
      fw_ov_wr_data.configure(.blk_parent(this));
      fw_ov_wr_data.build(csr_excl);
      default_map.add_reg(.rg(fw_ov_wr_data),
                          .offset(32'hc4));
      fw_ov_wr_data.add_hdl_path_slice(
          "u_reg.u_fw_ov_wr_data.qs",
          0, 32, 0, "BkdrRegPathRtl");

      observe_fifo_thresh =
          (entropy_src_reg_observe_fifo_thresh::
           type_id::create("observe_fifo_thresh"));
      observe_fifo_thresh.configure(.blk_parent(this));
      observe_fifo_thresh.build(csr_excl);
      default_map.add_reg(.rg(observe_fifo_thresh),
                          .offset(32'hc8));
      observe_fifo_thresh.add_hdl_path_slice(
          "u_reg.u_observe_fifo_thresh.q",
          0, 6, 0, "BkdrRegPathRtl");

      observe_fifo_depth =
          (entropy_src_reg_observe_fifo_depth::
           type_id::create("observe_fifo_depth"));
      observe_fifo_depth.configure(.blk_parent(this));
      observe_fifo_depth.build(csr_excl);
      default_map.add_reg(.rg(observe_fifo_depth),
                          .offset(32'hcc));
      observe_fifo_depth.add_hdl_path_slice(
          "u_reg.u_observe_fifo_depth.qs",
          0, 6, 0, "BkdrRegPathRtl");

      debug_status =
          (entropy_src_reg_debug_status::
           type_id::create("debug_status"));
      debug_status.configure(.blk_parent(this));
      debug_status.build(csr_excl);
      default_map.add_reg(.rg(debug_status),
                          .offset(32'hd0));
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_entropy_fifo_depth.qs",
          0, 2, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_sha3_fsm.qs",
          3, 3, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_sha3_block_pr.qs",
          6, 1, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_sha3_squeezing.qs",
          7, 1, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_sha3_absorbed.qs",
          8, 1, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_sha3_err.qs",
          9, 1, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_main_sm_idle.qs",
          16, 1, 0, "BkdrRegPathRtl");
      debug_status.add_hdl_path_slice(
          "u_reg.u_debug_status_main_sm_boot_done.qs",
          17, 1, 0, "BkdrRegPathRtl");

      recov_alert_sts =
          (entropy_src_reg_recov_alert_sts::
           type_id::create("recov_alert_sts"));
      recov_alert_sts.configure(.blk_parent(this));
      recov_alert_sts.build(csr_excl);
      default_map.add_reg(.rg(recov_alert_sts),
                          .offset(32'hd4));
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fips_enable_field_alert.q",
          0, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_entropy_data_reg_en_field_alert.q",
          1, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_module_enable_field_alert.q",
          2, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_threshold_scope_field_alert.q",
          3, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_rng_bit_enable_field_alert.q",
          5, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fw_ov_sha3_start_field_alert.q",
          7, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fw_ov_mode_field_alert.q",
          8, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fw_ov_entropy_insert_field_alert.q",
          9, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_route_field_alert.q",
          10, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_type_field_alert.q",
          11, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_main_sm_alert.q",
          12, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_bus_cmp_alert.q",
          13, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_thresh_cfg_alert.q",
          14, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_fw_ov_wr_alert.q",
          15, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_es_fw_ov_disable_alert.q",
          16, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_fips_flag_field_alert.q",
          17, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_rng_fips_field_alert.q",
          18, 1, 0, "BkdrRegPathRtl");
      recov_alert_sts.add_hdl_path_slice(
          "u_reg.u_recov_alert_sts_postht_entropy_drop_alert.q",
          31, 1, 0, "BkdrRegPathRtl");

      err_code =
          (entropy_src_reg_err_code::
           type_id::create("err_code"));
      err_code.configure(.blk_parent(this));
      err_code.build(csr_excl);
      default_map.add_reg(.rg(err_code),
                          .offset(32'hd8));
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_esrng_err.q",
          0, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_distr_err.q",
          1, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_observe_err.q",
          2, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sfifo_esfinal_err.q",
          3, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_es_ack_sm_err.q",
          20, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_es_main_sm_err.q",
          21, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_es_cntr_err.q",
          22, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sha3_state_err.q",
          23, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_sha3_rst_storage_err.q",
          24, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_write_err.q",
          28, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_read_err.q",
          29, 1, 0, "BkdrRegPathRtl");
      err_code.add_hdl_path_slice(
          "u_reg.u_err_code_fifo_state_err.q",
          30, 1, 0, "BkdrRegPathRtl");

      err_code_test =
          (entropy_src_reg_err_code_test::
           type_id::create("err_code_test"));
      err_code_test.configure(.blk_parent(this));
      err_code_test.build(csr_excl);
      default_map.add_reg(.rg(err_code_test),
                          .offset(32'hdc));
      err_code_test.add_hdl_path_slice(
          "u_reg.u_err_code_test.q",
          0, 5, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(err_code_test.get_full_name(),
                        CsrExclWrite, CsrNonInitTests);
      main_sm_state =
          (entropy_src_reg_main_sm_state::
           type_id::create("main_sm_state"));
      main_sm_state.configure(.blk_parent(this));
      main_sm_state.build(csr_excl);
      default_map.add_reg(.rg(main_sm_state),
                          .offset(32'he0));
      main_sm_state.add_hdl_path_slice(
          "u_reg.u_main_sm_state.q",
          0, 9, 0, "BkdrRegPathRtl");

      // assign locked reg to its regwen reg
      me_regwen.add_lockable_reg_or_fld(module_enable);
      regwen.add_lockable_reg_or_fld(conf);
      regwen.add_lockable_reg_or_fld(entropy_control);
      regwen.add_lockable_reg_or_fld(health_test_windows);
      regwen.add_lockable_reg_or_fld(repcnt_thresholds);
      regwen.add_lockable_reg_or_fld(repcnts_thresholds);
      regwen.add_lockable_reg_or_fld(adaptp_hi_thresholds);
      regwen.add_lockable_reg_or_fld(adaptp_lo_thresholds);
      regwen.add_lockable_reg_or_fld(bucket_thresholds);
      regwen.add_lockable_reg_or_fld(markov_hi_thresholds);
      regwen.add_lockable_reg_or_fld(markov_lo_thresholds);
      regwen.add_lockable_reg_or_fld(extht_hi_thresholds);
      regwen.add_lockable_reg_or_fld(extht_lo_thresholds);
      regwen.add_lockable_reg_or_fld(alert_threshold);
      regwen.add_lockable_reg_or_fld(fw_ov_control);
      regwen.add_lockable_reg_or_fld(observe_fifo_thresh);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : entropy_src_reg_block

endpackage

