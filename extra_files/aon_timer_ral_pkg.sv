// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// UVM Registers auto-generated by `reggen` containing data structure
package aon_timer_ral_pkg;
  // dep packages
  import uvm_pkg::*;
  import dv_base_reg_pkg::*;

  // macro includes
  `include "uvm_macros.svh"

  // Forward declare all register/memory/block classes
  typedef class aon_timer_reg_alert_test;
  typedef class aon_timer_reg_wkup_ctrl;
  typedef class aon_timer_reg_wkup_thold_hi;
  typedef class aon_timer_reg_wkup_thold_lo;
  typedef class aon_timer_reg_wkup_count_hi;
  typedef class aon_timer_reg_wkup_count_lo;
  typedef class aon_timer_reg_wdog_regwen;
  typedef class aon_timer_reg_wdog_ctrl;
  typedef class aon_timer_reg_wdog_bark_thold;
  typedef class aon_timer_reg_wdog_bite_thold;
  typedef class aon_timer_reg_wdog_count;
  typedef class aon_timer_reg_intr_state;
  typedef class aon_timer_reg_intr_test;
  typedef class aon_timer_reg_wkup_cause;
  typedef class aon_timer_reg_block;

  class aon_timer_reg_alert_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field fatal_fault;

    `uvm_object_utils(aon_timer_reg_alert_test)

    function new(string       name = "aon_timer_reg_alert_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      fatal_fault =
          (dv_base_reg_field::
           type_id::create("fatal_fault"));
      fatal_fault.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      fatal_fault.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aon_timer_reg_alert_test

  class aon_timer_reg_wkup_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable;
    rand dv_base_reg_field prescaler;

    `uvm_object_utils(aon_timer_reg_wkup_ctrl)

    function new(string       name = "aon_timer_reg_wkup_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable =
          (dv_base_reg_field::
           type_id::create("enable"));
      enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable.set_original_access("RW");
      prescaler =
          (dv_base_reg_field::
           type_id::create("prescaler"));
      prescaler.configure(
        .parent(this),
        .size(12),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      prescaler.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wkup_ctrl

  class aon_timer_reg_wkup_thold_hi extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold_hi;

    `uvm_object_utils(aon_timer_reg_wkup_thold_hi)

    function new(string       name = "aon_timer_reg_wkup_thold_hi",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold_hi =
          (dv_base_reg_field::
           type_id::create("threshold_hi"));
      threshold_hi.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold_hi.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wkup_thold_hi

  class aon_timer_reg_wkup_thold_lo extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold_lo;

    `uvm_object_utils(aon_timer_reg_wkup_thold_lo)

    function new(string       name = "aon_timer_reg_wkup_thold_lo",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold_lo =
          (dv_base_reg_field::
           type_id::create("threshold_lo"));
      threshold_lo.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold_lo.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wkup_thold_lo

  class aon_timer_reg_wkup_count_hi extends dv_base_reg;
    // fields
    rand dv_base_reg_field count_hi;

    `uvm_object_utils(aon_timer_reg_wkup_count_hi)

    function new(string       name = "aon_timer_reg_wkup_count_hi",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count_hi =
          (dv_base_reg_field::
           type_id::create("count_hi"));
      count_hi.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count_hi.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wkup_count_hi

  class aon_timer_reg_wkup_count_lo extends dv_base_reg;
    // fields
    rand dv_base_reg_field count_lo;

    `uvm_object_utils(aon_timer_reg_wkup_count_lo)

    function new(string       name = "aon_timer_reg_wkup_count_lo",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count_lo =
          (dv_base_reg_field::
           type_id::create("count_lo"));
      count_lo.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count_lo.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wkup_count_lo

  class aon_timer_reg_wdog_regwen extends dv_base_reg;
    // fields
    rand dv_base_reg_field regwen;

    `uvm_object_utils(aon_timer_reg_wdog_regwen)

    function new(string       name = "aon_timer_reg_wdog_regwen",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      regwen =
          (dv_base_reg_field::
           type_id::create("regwen"));
      regwen.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h1),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      regwen.set_original_access("W0C");
    endfunction : build
  endclass : aon_timer_reg_wdog_regwen

  class aon_timer_reg_wdog_ctrl extends dv_base_reg;
    // fields
    rand dv_base_reg_field enable;
    rand dv_base_reg_field pause_in_sleep;

    `uvm_object_utils(aon_timer_reg_wdog_ctrl)

    function new(string       name = "aon_timer_reg_wdog_ctrl",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      enable =
          (dv_base_reg_field::
           type_id::create("enable"));
      enable.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      enable.set_original_access("RW");
      pause_in_sleep =
          (dv_base_reg_field::
           type_id::create("pause_in_sleep"));
      pause_in_sleep.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      pause_in_sleep.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wdog_ctrl

  class aon_timer_reg_wdog_bark_thold extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold;

    `uvm_object_utils(aon_timer_reg_wdog_bark_thold)

    function new(string       name = "aon_timer_reg_wdog_bark_thold",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold =
          (dv_base_reg_field::
           type_id::create("threshold"));
      threshold.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wdog_bark_thold

  class aon_timer_reg_wdog_bite_thold extends dv_base_reg;
    // fields
    rand dv_base_reg_field threshold;

    `uvm_object_utils(aon_timer_reg_wdog_bite_thold)

    function new(string       name = "aon_timer_reg_wdog_bite_thold",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      threshold =
          (dv_base_reg_field::
           type_id::create("threshold"));
      threshold.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      threshold.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wdog_bite_thold

  class aon_timer_reg_wdog_count extends dv_base_reg;
    // fields
    rand dv_base_reg_field count;

    `uvm_object_utils(aon_timer_reg_wdog_count)

    function new(string       name = "aon_timer_reg_wdog_count",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      count =
          (dv_base_reg_field::
           type_id::create("count"));
      count.configure(
        .parent(this),
        .size(32),
        .lsb_pos(0),
        .access("RW"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      count.set_original_access("RW");
    endfunction : build
  endclass : aon_timer_reg_wdog_count

  class aon_timer_reg_intr_state extends dv_base_reg;
    // fields
    rand dv_base_reg_field wkup_timer_expired;
    rand dv_base_reg_field wdog_timer_bark;

    `uvm_object_utils(aon_timer_reg_intr_state)

    function new(string       name = "aon_timer_reg_intr_state",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      wkup_timer_expired =
          (dv_base_reg_field::
           type_id::create("wkup_timer_expired"));
      wkup_timer_expired.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wkup_timer_expired.set_original_access("W1C");
      wdog_timer_bark =
          (dv_base_reg_field::
           type_id::create("wdog_timer_bark"));
      wdog_timer_bark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("W1C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wdog_timer_bark.set_original_access("W1C");
    endfunction : build
  endclass : aon_timer_reg_intr_state

  class aon_timer_reg_intr_test extends dv_base_reg;
    // fields
    rand dv_base_reg_field wkup_timer_expired;
    rand dv_base_reg_field wdog_timer_bark;

    `uvm_object_utils(aon_timer_reg_intr_test)

    function new(string       name = "aon_timer_reg_intr_test",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      wkup_timer_expired =
          (dv_base_reg_field::
           type_id::create("wkup_timer_expired"));
      wkup_timer_expired.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wkup_timer_expired.set_original_access("WO");
      wdog_timer_bark =
          (dv_base_reg_field::
           type_id::create("wdog_timer_bark"));
      wdog_timer_bark.configure(
        .parent(this),
        .size(1),
        .lsb_pos(1),
        .access("WO"),
        .mubi_access("NONE"),
        .volatile(0),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      wdog_timer_bark.set_original_access("WO");
      set_is_ext_reg(1);
    endfunction : build
  endclass : aon_timer_reg_intr_test

  class aon_timer_reg_wkup_cause extends dv_base_reg;
    // fields
    rand dv_base_reg_field cause;

    `uvm_object_utils(aon_timer_reg_wkup_cause)

    function new(string       name = "aon_timer_reg_wkup_cause",
                 int unsigned n_bits = 32,
                 int          has_coverage = UVM_NO_COVERAGE);
      super.new(name, n_bits, has_coverage);
    endfunction : new

    virtual function void build(csr_excl_item csr_excl = null);
      cause =
          (dv_base_reg_field::
           type_id::create("cause"));
      cause.configure(
        .parent(this),
        .size(1),
        .lsb_pos(0),
        .access("W0C"),
        .mubi_access("NONE"),
        .volatile(1),
        .reset(32'h0),
        .has_reset(1),
        .is_rand(1),
        .individually_accessible(1));

      cause.set_original_access("W0C");
    endfunction : build
  endclass : aon_timer_reg_wkup_cause

  class aon_timer_reg_block extends dv_base_reg_block;
    // registers
    rand aon_timer_reg_alert_test alert_test;
    rand aon_timer_reg_wkup_ctrl wkup_ctrl;
    rand aon_timer_reg_wkup_thold_hi wkup_thold_hi;
    rand aon_timer_reg_wkup_thold_lo wkup_thold_lo;
    rand aon_timer_reg_wkup_count_hi wkup_count_hi;
    rand aon_timer_reg_wkup_count_lo wkup_count_lo;
    rand aon_timer_reg_wdog_regwen wdog_regwen;
    rand aon_timer_reg_wdog_ctrl wdog_ctrl;
    rand aon_timer_reg_wdog_bark_thold wdog_bark_thold;
    rand aon_timer_reg_wdog_bite_thold wdog_bite_thold;
    rand aon_timer_reg_wdog_count wdog_count;
    rand aon_timer_reg_intr_state intr_state;
    rand aon_timer_reg_intr_test intr_test;
    rand aon_timer_reg_wkup_cause wkup_cause;

    `uvm_object_utils(aon_timer_reg_block)

    function new(string name = "aon_timer_reg_block",
                 int    has_coverage = UVM_NO_COVERAGE);
      super.new(name, has_coverage);
    endfunction : new

    virtual function void build(uvm_reg_addr_t base_addr,
                                csr_excl_item csr_excl = null);
      // create default map
      this.default_map = create_map(.name("default_map"),
                                    .base_addr(base_addr),
                                    .n_bytes(4),
                                    .endian(UVM_LITTLE_ENDIAN));
      if (csr_excl == null) begin
        csr_excl = csr_excl_item::type_id::create("csr_excl");
        this.csr_excl = csr_excl;
      end
      set_hdl_path_root("tb.dut", "BkdrRegPathRtl");
      set_hdl_path_root("tb.dut", "BkdrRegPathRtlShadow");
      // create registers
      alert_test =
          (aon_timer_reg_alert_test::
           type_id::create("alert_test"));
      alert_test.configure(.blk_parent(this));
      alert_test.build(csr_excl);
      default_map.add_reg(.rg(alert_test),
                          .offset(32'h0));
      alert_test.add_hdl_path_slice(
          "u_reg.u_alert_test.qs",
          0, 1, 0, "BkdrRegPathRtl");

      wkup_ctrl =
          (aon_timer_reg_wkup_ctrl::
           type_id::create("wkup_ctrl"));
      wkup_ctrl.configure(.blk_parent(this));
      wkup_ctrl.build(csr_excl);
      default_map.add_reg(.rg(wkup_ctrl),
                          .offset(32'h4));
      wkup_ctrl.add_hdl_path_slice(
          "u_reg.u_wkup_ctrl_enable.q",
          0, 1, 0, "BkdrRegPathRtl");
      wkup_ctrl.add_hdl_path_slice(
          "u_reg.u_wkup_ctrl_prescaler.q",
          1, 12, 0, "BkdrRegPathRtl");

      wkup_thold_hi =
          (aon_timer_reg_wkup_thold_hi::
           type_id::create("wkup_thold_hi"));
      wkup_thold_hi.configure(.blk_parent(this));
      wkup_thold_hi.build(csr_excl);
      default_map.add_reg(.rg(wkup_thold_hi),
                          .offset(32'h8));
      wkup_thold_hi.add_hdl_path_slice(
          "u_reg.u_wkup_thold_hi.q",
          0, 32, 0, "BkdrRegPathRtl");

      wkup_thold_lo =
          (aon_timer_reg_wkup_thold_lo::
           type_id::create("wkup_thold_lo"));
      wkup_thold_lo.configure(.blk_parent(this));
      wkup_thold_lo.build(csr_excl);
      default_map.add_reg(.rg(wkup_thold_lo),
                          .offset(32'hc));
      wkup_thold_lo.add_hdl_path_slice(
          "u_reg.u_wkup_thold_lo.q",
          0, 32, 0, "BkdrRegPathRtl");

      wkup_count_hi =
          (aon_timer_reg_wkup_count_hi::
           type_id::create("wkup_count_hi"));
      wkup_count_hi.configure(.blk_parent(this));
      wkup_count_hi.build(csr_excl);
      default_map.add_reg(.rg(wkup_count_hi),
                          .offset(32'h10));
      wkup_count_hi.add_hdl_path_slice(
          "u_reg.u_wkup_count_hi.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wkup_count_hi.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      wkup_count_lo =
          (aon_timer_reg_wkup_count_lo::
           type_id::create("wkup_count_lo"));
      wkup_count_lo.configure(.blk_parent(this));
      wkup_count_lo.build(csr_excl);
      default_map.add_reg(.rg(wkup_count_lo),
                          .offset(32'h14));
      wkup_count_lo.add_hdl_path_slice(
          "u_reg.u_wkup_count_lo.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wkup_count_lo.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      wdog_regwen =
          (aon_timer_reg_wdog_regwen::
           type_id::create("wdog_regwen"));
      wdog_regwen.configure(.blk_parent(this));
      wdog_regwen.build(csr_excl);
      default_map.add_reg(.rg(wdog_regwen),
                          .offset(32'h18));
      wdog_regwen.add_hdl_path_slice(
          "u_reg.u_wdog_regwen.q",
          0, 1, 0, "BkdrRegPathRtl");

      wdog_ctrl =
          (aon_timer_reg_wdog_ctrl::
           type_id::create("wdog_ctrl"));
      wdog_ctrl.configure(.blk_parent(this));
      wdog_ctrl.build(csr_excl);
      default_map.add_reg(.rg(wdog_ctrl),
                          .offset(32'h1c));
      wdog_ctrl.add_hdl_path_slice(
          "u_reg.u_wdog_ctrl_enable.q",
          0, 1, 0, "BkdrRegPathRtl");
      wdog_ctrl.add_hdl_path_slice(
          "u_reg.u_wdog_ctrl_pause_in_sleep.q",
          1, 1, 0, "BkdrRegPathRtl");

      wdog_bark_thold =
          (aon_timer_reg_wdog_bark_thold::
           type_id::create("wdog_bark_thold"));
      wdog_bark_thold.configure(.blk_parent(this));
      wdog_bark_thold.build(csr_excl);
      default_map.add_reg(.rg(wdog_bark_thold),
                          .offset(32'h20));
      wdog_bark_thold.add_hdl_path_slice(
          "u_reg.u_wdog_bark_thold.q",
          0, 32, 0, "BkdrRegPathRtl");

      wdog_bite_thold =
          (aon_timer_reg_wdog_bite_thold::
           type_id::create("wdog_bite_thold"));
      wdog_bite_thold.configure(.blk_parent(this));
      wdog_bite_thold.build(csr_excl);
      default_map.add_reg(.rg(wdog_bite_thold),
                          .offset(32'h24));
      wdog_bite_thold.add_hdl_path_slice(
          "u_reg.u_wdog_bite_thold.q",
          0, 32, 0, "BkdrRegPathRtl");

      wdog_count =
          (aon_timer_reg_wdog_count::
           type_id::create("wdog_count"));
      wdog_count.configure(.blk_parent(this));
      wdog_count.build(csr_excl);
      default_map.add_reg(.rg(wdog_count),
                          .offset(32'h28));
      wdog_count.add_hdl_path_slice(
          "u_reg.u_wdog_count.q",
          0, 32, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wdog_count.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      intr_state =
          (aon_timer_reg_intr_state::
           type_id::create("intr_state"));
      intr_state.configure(.blk_parent(this));
      intr_state.build(csr_excl);
      default_map.add_reg(.rg(intr_state),
                          .offset(32'h2c));
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_wkup_timer_expired.q",
          0, 1, 0, "BkdrRegPathRtl");
      intr_state.add_hdl_path_slice(
          "u_reg.u_intr_state_wdog_timer_bark.q",
          1, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(intr_state.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      intr_test =
          (aon_timer_reg_intr_test::
           type_id::create("intr_test"));
      intr_test.configure(.blk_parent(this));
      intr_test.build(csr_excl);
      default_map.add_reg(.rg(intr_test),
                          .offset(32'h30));
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_wkup_timer_expired.qs",
          0, 1, 0, "BkdrRegPathRtl");
      intr_test.add_hdl_path_slice(
          "u_reg.u_intr_test_wdog_timer_bark.qs",
          1, 1, 0, "BkdrRegPathRtl");

      wkup_cause =
          (aon_timer_reg_wkup_cause::
           type_id::create("wkup_cause"));
      wkup_cause.configure(.blk_parent(this));
      wkup_cause.build(csr_excl);
      default_map.add_reg(.rg(wkup_cause),
                          .offset(32'h34));
      wkup_cause.add_hdl_path_slice(
          "u_reg.u_wkup_cause.q",
          0, 1, 0, "BkdrRegPathRtl");

      // create register tags
      csr_excl.add_excl(wkup_cause.get_full_name(),
                        CsrExclWriteCheck, CsrNonInitTests);
      // assign locked reg to its regwen reg
      wdog_regwen.add_lockable_reg_or_fld(wdog_ctrl);
      wdog_regwen.add_lockable_reg_or_fld(wdog_bark_thold);
      wdog_regwen.add_lockable_reg_or_fld(wdog_bite_thold);


      // Create functional coverage for comportable IP-specific specialized registers.
      // This function can only be called if it is a root block to get the correct gating condition
      // and avoid creating duplicated cov.
      if (this.get_parent() == null && en_dv_reg_cov) create_cov();
    endfunction : build
  endclass : aon_timer_reg_block

endpackage

